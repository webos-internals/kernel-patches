--- a/drivers/cpufreq/Kconfig	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Kconfig	2011-10-06 20:37:21.000000000 -0400
@@ -18,6 +18,33 @@
 config CPU_FREQ_TABLE
 	tristate
 
+config CPU_FREQ_OVERRIDE
+	bool "Enable CPU options override"
+	default y
+	help
+	  Say Y here
+
+config CPU_FREQ_OVERRIDE_L2_HACK
+	bool "Enable overclock L2 freqs"
+	depends on CPU_FREQ_OVERRIDE
+	default n
+	help
+	  Say Y here
+
+config CPU_FREQ_OVERRIDE_VOLT_CONFIG
+	bool "Enable CPU voltage tweaking"
+	depends on CPU_FREQ_OVERRIDE
+	default y
+	help
+	  Say Y here
+
+config CPU_FREQ_OVERRIDE_TURBO_MODE
+	bool "Enable static dual-core"
+	depends on CPU_FREQ_OVERRIDE
+	default y
+	help
+	  Say Y here
+
 config CPU_FREQ_DEBUG
 	bool "Enable CPUfreq debugging"
 	help
--- a/drivers/cpufreq/Makefile	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Makefile	2011-08-19 16:12:28.000000000 -0400
@@ -10,6 +10,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE)	+= cpufreq_ondemand_tickle.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_OVERRIDE)		+= cpufreq_override.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
--- a/arch/arm/mach-msm/acpuclock-8x60.c	2011-08-02 16:04:21.000000000 -0400
+++ b/arch/arm/mach-msm/acpuclock-8x60.c	2011-09-25 14:09:43.000000000 -0400
@@ -231,6 +233,8 @@
 static struct clkctl_l2_speed *l2_freq_tbl;
 static unsigned int l2_freq_tbl_size;
 
+#include "override_plug.c"
+
 unsigned long acpuclk_get_rate(int cpu)
 {
 	return drv_state.current_speed[cpu]->acpuclk_khz;
--- a/drivers/base/cpu.c	2010-08-01 18:11:14.000000000 -0400
+++ b/drivers/base/cpu.c	2011-10-06 20:39:07.000000000 -0400
@@ -14,6 +14,10 @@
 
 #include "base.h"
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+bool cpufreq_override_get_state(void);
+#endif
+
 static struct sysdev_class_attribute *cpu_sysdev_class_attrs[];
 
 struct sysdev_class cpu_sysdev_class = {
@@ -37,9 +41,14 @@
 				 const char *buf, size_t count)
 {
 	struct cpu *cpu = container_of(dev, struct cpu, sysdev);
-	ssize_t ret;
+	ssize_t ret = 0;
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+	if(cpufreq_override_get_state()) goto out;
+#endif
 	cpu_hotplug_driver_lock();
+	// uncomment to prove to lusers what actually shuts off the CPU!
+	//printk("CPU SNOOP: process \"%s\" set cpu: %s\n",current->comm,buf[0] == '0' ? "off" : "on");
 	switch (buf[0]) {
 	case '0':
 		ret = cpu_down(cpu->sysdev.id);
@@ -55,7 +64,9 @@
 		ret = -EINVAL;
 	}
 	cpu_hotplug_driver_unlock();
-
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+out:
+#endif
 	if (ret >= 0)
 		ret = count;
 	return ret;
--- a/drivers/cpufreq/cpufreq_override.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/cpufreq/cpufreq_override.c	2011-10-06 20:32:51.000000000 -0400
@@ -0,0 +1,341 @@
+/*
+ *  drivers/cpufreq/cpufreq_override.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/cpu.h>
+#include <linux/sysfs.h>
+#include <linux/cpufreq.h>
+#include <linux/jiffies.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
+#include <linux/string.h>
+#include <linux/kernel_stat.h>
+
+// Voltage min
+#define VDD_MIN 800000
+
+// Voltage max
+#define VDD_MAX 1600000
+
+// Max Freq count. Not the actual number of freqs
+#define MAX_FREQS 35
+
+// Power saving mode
+#define POWERSAVE 0
+
+// L2 Boost mode.  This requires mods in acpuclock-8x60.c
+#define L2_BOOST 0
+
+// Turbo Mode default state (both CPUs online all the time)
+#define TURBOMODE 1
+
+/* ************* end of tunables ***************************************** */
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+void acpuclk_get_voltages(unsigned int acpu_freq_vlt_tbl[]);
+void acpuclk_set_voltages(unsigned int acpu_freq_vlt_tbl[]);
+#endif
+
+unsigned int acpuclk_get_freqs(unsigned int acpu_freq_tbl[]);
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+void acpuclk_set_l2_hack(bool state);
+static bool l2boost = L2_BOOST;
+#endif
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+static bool power_save = POWERSAVE;
+static bool lcd_state = 1;
+static bool turbomode = TURBOMODE;
+#endif
+
+static unsigned int freq_table[MAX_FREQS];
+static unsigned int nr_freqs;
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+static void cpu_state(bool state)
+{
+	struct sys_device *dev = get_cpu_sysdev(1);
+
+	if(!state) {
+		cpu_hotplug_driver_lock();
+		if(!cpu_down(1)) kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+		cpu_hotplug_driver_unlock();
+	}
+	else {
+		cpu_hotplug_driver_lock();
+		if(!cpu_up(1)) kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+		cpu_hotplug_driver_unlock();
+	}
+}
+
+bool cpufreq_override_get_state(void)
+{
+	unsigned int ret = 0;
+
+	if(lcd_state) ret = power_save ? 0 : turbomode;
+
+	return ret;
+}
+EXPORT_SYMBOL(cpufreq_override_get_state);
+
+void cpufreq_override_set_lcd_state(bool state)
+{
+	lcd_state = state;
+	printk("override: lcd state=%u\n",state);
+
+	// If screen is off, take cpu offline if in power save mode
+	if(power_save && !lcd_state) cpu_state(0);
+
+	// force CPU online regardless
+	if(lcd_state) cpu_state(1);
+}
+EXPORT_SYMBOL(cpufreq_override_set_lcd_state);
+#endif
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+static ssize_t show_vdd_max(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%u\n", VDD_MAX);
+}
+
+static ssize_t show_vdd_min(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%u\n", VDD_MIN);
+}
+
+static ssize_t show_vdd(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	unsigned int i, acpu_freq_vlt_tbl[MAX_FREQS];
+	char tmp[250];
+
+	acpuclk_get_voltages(acpu_freq_vlt_tbl);
+
+	strcpy(buf,"");
+
+	for(i=0 ; i < nr_freqs ; ++i) {
+		sprintf(tmp,"%u ",acpu_freq_vlt_tbl[i]);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+static ssize_t store_vdd(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int i = 0, acpu_freq_vlt_tbl[MAX_FREQS];
+	unsigned int *c = acpu_freq_vlt_tbl;
+	const char *wp = buf;
+
+	for(i = 0; i < nr_freqs; i++) {
+		wp=skip_spaces(wp);
+		sscanf(wp,"%u",&c[i]);
+		if(c[i] < VDD_MIN || c[i] > VDD_MAX) break;
+		wp=strchr(wp,' ')+1;
+  	}
+
+	if(i != nr_freqs)
+		printk("override: store_vdd invalid\n");
+	else {
+		acpuclk_set_voltages(acpu_freq_vlt_tbl);
+
+		printk("override: set vdd %s\n",buf);
+	}
+
+	return count;
+}
+#endif
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+static ssize_t show_power_saver(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf,"%u\n",power_save);
+}
+
+static ssize_t store_power_saver(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int tmp;
+
+	if(sscanf(buf, "%u", &tmp) == 1) {
+		power_save = (tmp != 0 && tmp != 1) ? power_save : tmp;
+
+		if(power_save) {
+			cpu_state(0);
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+			printk("override: disabling L2 boost...\n");
+			l2boost = 0;
+			acpuclk_set_l2_hack(0);
+#endif
+		}
+		else cpu_state(1);
+
+		printk("override: set power_save: %u\n",power_save);
+	}	
+	else
+		printk("override: invalid power save mode\n");
+
+	return count;
+}
+
+static ssize_t show_turbo_mode(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf,"%u\n",turbomode);
+}
+
+static ssize_t store_turbo_mode(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int tmp;
+
+	if(sscanf(buf, "%u", &tmp) == 1) {
+		turbomode = (tmp != 0 && tmp != 1) ? turbomode : tmp;
+
+		if(turbomode) cpu_state(1);
+		else cpu_state(0);
+
+		printk("override: set turbo_mode: %u\n",turbomode);
+	}
+	else
+		printk("override: invalid turbo_mode\n");
+
+	return count;
+}
+#endif
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+static ssize_t show_l2_boost(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf,"%u\n",l2boost);
+}
+
+static ssize_t store_l2_boost(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int tmp;
+
+	if(sscanf(buf, "%u", &tmp) == 1) {
+		l2boost = (tmp != 0 && tmp != 1) ? l2boost : tmp;
+		if(l2boost) acpuclk_set_l2_hack(1);
+		else acpuclk_set_l2_hack(0);
+
+		printk("override: set l2 boost: %u\n",l2boost);
+	}       
+	else
+		printk("override: invalid l2 boost mode\n");
+
+	return count;
+}
+#endif
+
+static ssize_t show_vdd_freqs(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	unsigned int i;
+	char tmp[250];
+
+	strcpy(buf,"");
+
+	for(i=0 ; i < nr_freqs ; ++i) {
+		sprintf(tmp,"%u ", freq_table[i]);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+define_one_global_ro(vdd_min);
+define_one_global_ro(vdd_max);
+define_one_global_rw(vdd);
+#endif
+define_one_global_ro(vdd_freqs);
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+define_one_global_rw(power_saver);
+define_one_global_rw(turbo_mode);
+#endif
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+define_one_global_rw(l2_boost);
+#endif
+
+static struct attribute *default_attrs[] = {
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+	&vdd.attr,
+	&vdd_min.attr,
+	&vdd_max.attr,
+#endif
+	&vdd_freqs.attr,
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+	&power_saver.attr,
+	&turbo_mode.attr,
+#endif
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+	&l2_boost.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group override_attr_group = {
+	.attrs = default_attrs,
+	.name = "override"
+};
+
+static int __init cpufreq_override_driver_init(void)
+{
+
+	// not sure why cpufreq_frequency_get_table doesnt work here
+	nr_freqs = acpuclk_get_freqs(freq_table);
+
+	printk("override: freqs configured: %u\n",nr_freqs);
+
+/*	for(i = 0; (table[i].frequency |= CPUFREQ_TABLE_END); i++) {
+		if (table[i].frequency == CPUFREQ_ENTRY_INVALID) continue;
+		freq_table[i] = table[i].frequency;
+	}
+
+	nr_freqs = table[i].index; */
+
+	printk("override: initialized!\n");
+
+	return sysfs_create_group(cpufreq_global_kobject,&override_attr_group);
+}
+
+static void __exit cpufreq_override_driver_exit(void)
+{
+	sysfs_remove_group(cpufreq_global_kobject, &override_attr_group);
+}
+
+MODULE_AUTHOR("marco@unixpsycho.com");
+MODULE_DESCRIPTION("'cpufreq_override' - A driver to do cool stuff ");
+MODULE_LICENSE("GPL");
+
+module_init(cpufreq_override_driver_init);
+module_exit(cpufreq_override_driver_exit);
+
--- a/arch/arm/mach-msm/override_plug.c	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-msm/override_plug.c	2011-10-05 19:54:53.000000000 -0400
@@ -0,0 +1,86 @@
+/*
+ *  override_plug.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+
+// define L2 overclock table indexes from l2_freq_tbl_v2 L2(x)
+//  set it the same to render it useless
+#define L2_OCLK_IDX 17
+#define L2_NORM_IDX 16
+
+// Minimum LVAL freq for L2 overclock 54 MHz * L_VAL
+#define MIN_LVAL_L2 0x20
+
+void acpuclk_set_l2_hack(bool state)
+{
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2 + 7; f->acpuclk_khz != 0; f++) {
+		if(f->use_for_scaling[0] == 0) continue;
+		if(f->l_val < MIN_LVAL_L2) continue;
+		f->l2_level = (state) ? L2(L2_OCLK_IDX) : L2(L2_NORM_IDX);
+	}
+}
+EXPORT_SYMBOL(acpuclk_set_l2_hack);
+#endif
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+void acpuclk_get_voltages(unsigned int acpu_freq_vlt_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		if(f->use_for_scaling[0] == 0) continue;
+		acpu_freq_vlt_tbl[i] = f->vdd_sc;
+		i++;
+	}
+
+}
+EXPORT_SYMBOL(acpuclk_get_voltages);
+
+void acpuclk_set_voltages(unsigned int acpu_freq_vlt_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		if(f->use_for_scaling[0] == 0) continue;
+		f->vdd_sc = acpu_freq_vlt_tbl[i];
+		i++;
+	}
+}
+EXPORT_SYMBOL(acpuclk_set_voltages);
+#endif
+
+unsigned int acpuclk_get_freqs(unsigned int acpu_freq_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		if(!f->use_for_scaling[0]) continue;
+		acpu_freq_tbl[i] = f->acpuclk_khz;
+		i++;
+	}
+
+	return i;
+}
+EXPORT_SYMBOL(acpuclk_get_freqs);
--- a/drivers/video/msm_pe/msm_fb.c	2011-08-02 16:04:22.000000000 -0400
+++ b/drivers/video/msm_pe/msm_fb.c	2011-10-06 20:34:04.000000000 -0400
@@ -51,6 +51,10 @@
 #include "mdp.h"
 #include "mdp4.h"
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+void cpufreq_override_set_lcd_state(bool state);
+#endif
+
 #ifdef CONFIG_FB_MSM_LOGO
 #define INIT_IMAGE_FILE "/initlogo.rle"
 extern int load_565rle_image(char *filename);
@@ -354,6 +358,10 @@
 			//fb_set_suspend(mfd->fbi[0], FBINFO_STATE_RUNNING);
 
 			mfd->suspended = false;
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+                        cpufreq_override_set_lcd_state(1);
+#endif
 		}
 
 	}
@@ -374,6 +382,10 @@
 				//fb_set_suspend(mfd->fbi[0], FBINFO_STATE_SUSPENDED);
 				mfd->pdev->dev.power.power_state = PMSG_SUSPEND;
 				mfd->suspended = true;
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_TURBO_MODE
+                                cpufreq_override_set_lcd_state(0);
+#endif
 			}
 		}
 
