--- a/drivers/cpufreq/Kconfig	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Kconfig	2011-08-02 17:39:57.000000000 -0400
@@ -87,6 +87,15 @@
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
+config CPU_FREQ_DEFAULT_GOV_SCREENSTATE
+        bool "screenstate"
+        select CPU_FREQ_GOV_SCREENSTATE
+        help
+          Use the CPUFreq governor 'screenstate' as default. This will
+	  scale the CPU frequency down when the LCD is off then scale
+	  back to max speed when LCD is powered on.  This also will not
+	  allow to set the CPU frequency manually.
+
 config CPU_FREQ_DEFAULT_GOV_ONDEMAND
 	bool "ondemand"
 	select CPU_FREQ_GOV_ONDEMAND
@@ -162,6 +171,16 @@
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_GOV_SCREENSTATE
+        tristate "'screenstate' governor for frequency scaling"
+        help
+          Enable this cpufreq governor to scale when LCD is on/off.
+
+          To compile this driver as a module, choose M here: the
+          module will be called cpufreq_screenstate.
+
+          If in doubt, say Y.
+
 config CPU_FREQ_GOV_ONDEMAND
 	tristate "'ondemand' cpufreq policy governor"
 	select CPU_FREQ_TABLE
--- a/drivers/cpufreq/Makefile	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Makefile	2011-08-02 17:39:57.000000000 -0400
@@ -10,6 +10,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE)	+= cpufreq_ondemand_tickle.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_SCREENSTATE)	+= cpufreq_screenstate.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
--- a/include/linux/cpufreq.h	2011-08-02 16:04:22.000000000 -0400
+++ b/include/linux/cpufreq.h	2011-08-02 17:39:57.000000000 -0400
@@ -410,6 +410,9 @@
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_userspace)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_SCREENSTATE)
+extern struct cpufreq_governor cpufreq_gov_screenstate;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_screenstate)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND)
 extern struct cpufreq_governor cpufreq_gov_ondemand;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_ondemand)
--- a/drivers/cpufreq/cpufreq_screenstate.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/cpufreq/cpufreq_screenstate.c	2011-08-02 17:58:19.000000000 -0400
@@ -0,0 +1,133 @@
+/*
+ *  linux/drivers/cpufreq/cpufreq_screenstate.c
+ *
+ *  Screenstate V1 1.5
+ *
+ *  Marco Benton marco@unixpsycho.com 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+
+static bool cpu_is_managed[NR_CPUS];
+static bool lcd_state;
+
+static DEFINE_MUTEX(screenstate_mutex);
+
+static void cpufreq_set_ss_state(void) {
+	int i;
+	struct cpufreq_policy *policy;
+
+	for(i=0;i < NR_CPUS;++i) {
+		if(!cpu_online(i) || !cpu_is_managed[i]) continue;
+
+		policy = cpufreq_cpu_get(i);
+		if(!lcd_state) __cpufreq_driver_target(policy,
+					policy->min, CPUFREQ_RELATION_L);
+		else
+			__cpufreq_driver_target(policy,
+					policy->max, CPUFREQ_RELATION_H);
+	}
+}
+
+static int cpufreq_governor_screenstate(struct cpufreq_policy *policy,
+				   unsigned int event) {
+	unsigned int cpu = policy->cpu;
+
+	switch (event) {
+		case CPUFREQ_GOV_START:
+			if (!cpu_online(cpu)) return -EINVAL;
+
+			mutex_lock(&screenstate_mutex);
+			if(cpu_is_managed[cpu]) break;
+
+			cpu_is_managed[cpu] = 1;
+			lcd_state = 1;
+			__cpufreq_driver_target(policy, policy->max,
+							CPUFREQ_RELATION_H);
+			
+			mutex_unlock(&screenstate_mutex);
+			printk("screenstate on CPU %d: initialized\n",cpu);
+			break;
+		case CPUFREQ_GOV_STOP:
+			mutex_lock(&screenstate_mutex);
+			cpu_is_managed[cpu] = 0;
+			mutex_unlock(&screenstate_mutex);
+			printk("screenstate on CPU %d: uninitialized\n",cpu);
+			break;
+		case CPUFREQ_GOV_LIMITS:
+			mutex_lock(&screenstate_mutex);
+			printk("screenstate: policy change\n");
+			if(lcd_state && (policy->cur != policy->max))
+				cpufreq_set_ss_state();
+			if(!lcd_state && (policy->cur != policy->min))
+				cpufreq_set_ss_state();
+			mutex_unlock(&screenstate_mutex);
+			break;
+		}
+		return 0;
+}
+
+struct cpufreq_governor cpufreq_gov_screenstate = {
+	.name		= "screenstate",
+	.governor	= cpufreq_governor_screenstate,
+	.owner		= THIS_MODULE,
+};
+
+static int __init cpufreq_gov_screenstate_init(void) {
+	return cpufreq_register_governor(&cpufreq_gov_screenstate);
+}
+
+static void __exit cpufreq_gov_screenstate_exit(void) {
+//	flush_scheduled_work();
+	cpufreq_unregister_governor(&cpufreq_gov_screenstate);
+}
+
+void cpufreq_gov_screenstate_lcdoff(void) {
+	if(cpu_is_managed[0]) { // FIXME
+		mutex_lock(&screenstate_mutex);
+		printk("screenstate: lcd off\n");
+		lcd_state = 0;
+		cpufreq_set_ss_state();
+		mutex_unlock(&screenstate_mutex);
+	}
+}
+EXPORT_SYMBOL(cpufreq_gov_screenstate_lcdoff);
+
+void cpufreq_gov_screenstate_lcdon(void) {
+        if(cpu_is_managed[0]) { // FIXME
+		mutex_lock(&screenstate_mutex);
+		printk("screenstate: lcd on\n");
+		lcd_state = 1;
+		cpufreq_set_ss_state();
+		mutex_unlock(&screenstate_mutex);
+        }
+}
+EXPORT_SYMBOL(cpufreq_gov_screenstate_lcdon);
+
+EXPORT_SYMBOL(cpufreq_gov_screenstate);
+
+MODULE_AUTHOR ("marco@unixpsycho.com");
+MODULE_DESCRIPTION ("CPUfreq policy governor 'screenstate'");
+MODULE_LICENSE ("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_SCREENSTATE
+fs_initcall(cpufreq_gov_screenstate_init);
+#else
+module_init(cpufreq_gov_screenstate_init);
+#endif
+module_exit(cpufreq_gov_screenstate_exit);
--- a/drivers/video/msm_pe/msm_fb.c	2011-08-02 16:04:22.000000000 -0400
+++ b/drivers/video/msm_pe/msm_fb.c	2011-08-02 18:24:08.000000000 -0400
@@ -51,6 +51,11 @@
 #include "mdp.h"
 #include "mdp4.h"
 
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+void cpufreq_gov_screenstate_lcdon(void);
+void cpufreq_gov_screenstate_lcdoff(void);
+#endif
+
 #ifdef CONFIG_FB_MSM_LOGO
 #define INIT_IMAGE_FILE "/initlogo.rle"
 extern int load_565rle_image(char *filename);
@@ -354,6 +359,11 @@
 			//fb_set_suspend(mfd->fbi[0], FBINFO_STATE_RUNNING);
 
 			mfd->suspended = false;
+
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+                        cpufreq_gov_screenstate_lcdon();
+#endif
+
 		}
 
 	}
@@ -374,6 +384,11 @@
 				//fb_set_suspend(mfd->fbi[0], FBINFO_STATE_SUSPENDED);
 				mfd->pdev->dev.power.power_state = PMSG_SUSPEND;
 				mfd->suspended = true;
+
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+                                cpufreq_gov_screenstate_lcdoff();
+#endif
+
 			}
 		}
 
