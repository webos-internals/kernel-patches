--- a/drivers/cpufreq/Kconfig	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Kconfig	2011-08-07 17:16:48.000000000 -0400
@@ -18,6 +18,11 @@
 config CPU_FREQ_TABLE
 	tristate
 
+config CPU_FREQ_OVERRIDE
+	bool "Enable CPU options override"
+	help
+	  Say Y here
+
 config CPU_FREQ_DEBUG
 	bool "Enable CPUfreq debugging"
 	help
--- a/drivers/cpufreq/Makefile	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Makefile	2011-08-07 17:18:06.000000000 -0400
@@ -10,6 +10,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE)	+= cpufreq_ondemand_tickle.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_OVERRIDE)		+= cpufreq_override.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
--- a/arch/arm/mach-msm/board-tenderloin.c	2011-08-02 16:04:21.000000000 -0400
+++ b/arch/arm/mach-msm/board-tenderloin.c	2011-08-17 19:55:15.000000000 -0400
@@ -402,7 +402,7 @@
 		.constraints = {
 			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
 			.min_uV = 840000,
-			.max_uV = 1250000,
+			.max_uV = 1600000,
 		},
 		.num_consumer_supplies = 1,
 		.consumer_supplies = &saw_s0_supply,
@@ -412,7 +412,7 @@
 		.constraints = {
 			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
 			.min_uV = 840000,
-			.max_uV = 1250000,
+			.max_uV = 1600000,
 		},
 		.num_consumer_supplies = 1,
 		.consumer_supplies = &saw_s1_supply,
@@ -3005,9 +3005,9 @@
 	RPM_VREG_INIT_LDO(PM8058_L24, 0, 1, 0, 1200000, 1200000, LDO150HMIN, 0),
 	RPM_VREG_INIT_LDO(PM8058_L25, 0, 1, 0, 1200000, 1200000, LDO150HMIN, 0),
 
-	RPM_VREG_INIT_SMPS(PM8058_S0, 0, 1, 1,  500000, 1250000,  SMPS_HMIN, 0,
+	RPM_VREG_INIT_SMPS(PM8058_S0, 0, 1, 1,  500000, 1600000,  SMPS_HMIN, 0,
 		RPM_VREG_FREQ_1p60),
-	RPM_VREG_INIT_SMPS(PM8058_S1, 0, 1, 1,  500000, 1250000,  SMPS_HMIN, 0,
+	RPM_VREG_INIT_SMPS(PM8058_S1, 0, 1, 1,  500000, 1600000,  SMPS_HMIN, 0,
 		RPM_VREG_FREQ_1p60),
 	RPM_VREG_INIT_SMPS(PM8058_S2, 0, 1, 0, 1200000, 1400000,  SMPS_HMIN,
 		RPM_VREG_PIN_CTRL_A0, RPM_VREG_FREQ_1p60),
+
--- a/arch/arm/mach-msm/acpuclock-8x60.c	2011-08-02 16:04:21.000000000 -0400
+++ b/arch/arm/mach-msm/acpuclock-8x60.c	2011-08-27 10:07:49.000000000 -0400
@@ -52,9 +52,9 @@
  * The PLL hardware is capable of 384MHz to 1536MHz. The L_VALs
  * used for calibration should respect these limits. */
 #define L_VAL_SCPLL_CAL_MIN	0x08 /* =  432 MHz with 27MHz source */
-#define L_VAL_SCPLL_CAL_MAX	0x1C /* = 1512 MHz with 27MHz source */
+#define L_VAL_SCPLL_CAL_MAX	0x24 /* = 1944 MHz with 27MHz source */
 
-#define MAX_VDD_SC		1250000 /* uV */
+#define MAX_VDD_SC		1600000 /* uV */
 #define MAX_AXI			 310500 /* KHz */
 #define SCPLL_LOW_VDD_FMAX	 594000 /* KHz */
 #define SCPLL_LOW_VDD		1000000 /* uV */
@@ -182,21 +182,21 @@
 static struct clkctl_l2_speed l2_freq_tbl_v2[] = {
 	[0]  = { MAX_AXI, 0, 0,    1000000, 1100000, 0},
 	[1]  = { 432000,  1, 0x08, 1000000, 1100000, 0},
-	[2]  = { 486000,  1, 0x09, 1000000, 1100000, 0},
-	[3]  = { 540000,  1, 0x0A, 1000000, 1100000, 0},
-	[4]  = { 594000,  1, 0x0B, 1000000, 1100000, 0},
-	[5]  = { 648000,  1, 0x0C, 1000000, 1100000, 1},
-	[6]  = { 702000,  1, 0x0D, 1100000, 1100000, 1},
-	[7]  = { 756000,  1, 0x0E, 1100000, 1100000, 1},
-	[8]  = { 810000,  1, 0x0F, 1100000, 1100000, 1},
-	[9]  = { 864000,  1, 0x10, 1100000, 1100000, 1},
-	[10] = { 918000,  1, 0x11, 1100000, 1100000, 2},
-	[11] = { 972000,  1, 0x12, 1100000, 1100000, 2},
-	[12] = {1026000,  1, 0x13, 1100000, 1100000, 2},
-	[13] = {1080000,  1, 0x14, 1100000, 1200000, 2},
-	[14] = {1134000,  1, 0x15, 1100000, 1200000, 2},
-	[15] = {1188000,  1, 0x16, 1200000, 1200000, 3},
-	[16] = {1404000,  1, 0x1A, 1200000, 1250000, 3},
+	[2]  = { 540000,  1, 0x0A, 1000000, 1100000, 0},
+	[3]  = { 648000,  1, 0x0C, 1000000, 1100000, 1},
+	[4]  = { 756000,  1, 0x0E, 1100000, 1100000, 1},
+	[5]  = { 864000,  1, 0x10, 1100000, 1100000, 1},
+	[6]  = { 918000,  1, 0x11, 1100000, 1100000, 2},
+	[7]  = { 972000,  1, 0x12, 1100000, 1100000, 2},
+	[8]  = {1026000,  1, 0x13, 1100000, 1100000, 2},
+	[9]  = {1080000,  1, 0x14, 1100000, 1200000, 2},
+	[10] = {1134000,  1, 0x15, 1100000, 1200000, 2},
+	[11] = {1188000,  1, 0x16, 1200000, 1200000, 3},
+	[12] = {1242000,  1, 0x17, 1200000, 1200000, 3},
+	[13] = {1350000,  1, 0x19, 1200000, 1250000, 3},
+	[14] = {1404000,  1, 0x1A, 1200000, 1250000, 3},
+	[15] = {1458000,  1, 0x1B, 1200000, 1250000, 3},
+	[16] = {1512000,  1, 0x1C, 1250000, 1250000, 3},
 };
 
 #define L2(x) (&l2_freq_tbl_v2[(x)])
@@ -207,21 +207,23 @@
   { {0, 0},  MAX_AXI, ACPU_AFAB,  1, 0, 0, 0,    L2(0),   875000, 0x03006000},
   { {1, 1},  384000,  ACPU_PLL_8, 3, 0, 0, 0,    L2(1),   875000, 0x03006000},
   { {1, 1},  432000,  ACPU_SCPLL, 0, 0, 1, 0x08, L2(1),   887500, 0x03006000},
-  { {1, 1},  486000,  ACPU_SCPLL, 0, 0, 1, 0x09, L2(2),   912500, 0x03006000},
-  { {1, 1},  540000,  ACPU_SCPLL, 0, 0, 1, 0x0A, L2(3),   925000, 0x03006000},
-  { {1, 1},  594000,  ACPU_SCPLL, 0, 0, 1, 0x0B, L2(4),   937500, 0x03006000},
-  { {1, 1},  648000,  ACPU_SCPLL, 0, 0, 1, 0x0C, L2(5),   950000, 0x03006000},
-  { {1, 1},  702000,  ACPU_SCPLL, 0, 0, 1, 0x0D, L2(6),   975000, 0x03006000},
-  { {1, 1},  756000,  ACPU_SCPLL, 0, 0, 1, 0x0E, L2(7),  1000000, 0x03006000},
-  { {1, 1},  810000,  ACPU_SCPLL, 0, 0, 1, 0x0F, L2(8),  1012500, 0x03006000},
-  { {1, 1},  864000,  ACPU_SCPLL, 0, 0, 1, 0x10, L2(9),  1037500, 0x03006000},
-  { {1, 1},  918000,  ACPU_SCPLL, 0, 0, 1, 0x11, L2(10), 1062500, 0x03006000},
-  { {1, 1},  972000,  ACPU_SCPLL, 0, 0, 1, 0x12, L2(11), 1087500, 0x03006000},
-  { {1, 1}, 1026000,  ACPU_SCPLL, 0, 0, 1, 0x13, L2(12), 1125000, 0x03006000},
-  { {1, 1}, 1080000,  ACPU_SCPLL, 0, 0, 1, 0x14, L2(13), 1137500, 0x03006000},
-  { {1, 1}, 1134000,  ACPU_SCPLL, 0, 0, 1, 0x15, L2(14), 1162500, 0x03006000},
-  { {1, 1}, 1188000,  ACPU_SCPLL, 0, 0, 1, 0x16, L2(15), 1187500, 0x03006000},
-  { {1, 1}, 1512000,  ACPU_SCPLL, 0, 0, 1, 0x1C, L2(16), 1250000, 0x03006000},
+  { {1, 1},  540000,  ACPU_SCPLL, 0, 0, 1, 0x0A, L2(2),   925000, 0x03006000},
+  { {1, 1},  648000,  ACPU_SCPLL, 0, 0, 1, 0x0C, L2(3),   950000, 0x03006000},
+  { {1, 1},  756000,  ACPU_SCPLL, 0, 0, 1, 0x0E, L2(4),  1000000, 0x03006000},
+  { {1, 1},  864000,  ACPU_SCPLL, 0, 0, 1, 0x10, L2(5),  1037500, 0x03006000},
+  { {1, 1},  918000,  ACPU_SCPLL, 0, 0, 1, 0x11, L2(6),  1062500, 0x03006000},
+  { {1, 1},  972000,  ACPU_SCPLL, 0, 0, 1, 0x12, L2(7),  1087500, 0x03006000},
+  { {1, 1}, 1026000,  ACPU_SCPLL, 0, 0, 1, 0x13, L2(8),  1125000, 0x03006000},
+  { {1, 1}, 1080000,  ACPU_SCPLL, 0, 0, 1, 0x14, L2(9),  1137500, 0x03006000},
+  { {1, 1}, 1134000,  ACPU_SCPLL, 0, 0, 1, 0x15, L2(10), 1162500, 0x03006000},
+  { {1, 1}, 1188000,  ACPU_SCPLL, 0, 0, 1, 0x16, L2(11), 1187500, 0x03006000},
+  { {1, 1}, 1242000,  ACPU_SCPLL, 0, 0, 1, 0x17, L2(12), 1190000, 0x03006000},
+  { {1, 1}, 1350000,  ACPU_SCPLL, 0, 0, 1, 0x19, L2(13), 1195000, 0x03006000},
+  { {1, 1}, 1458000,  ACPU_SCPLL, 0, 0, 1, 0x1B, L2(14), 1200000, 0x03006000},
+  { {1, 1}, 1512000,  ACPU_SCPLL, 0, 0, 1, 0x1C, L2(15), 1250000, 0x03006000},
+  { {1, 1}, 1728000,  ACPU_SCPLL, 0, 0, 1, 0x20, L2(16), 1350000, 0x03006000},
+  { {1, 1}, 1836000,  ACPU_SCPLL, 0, 0, 1, 0x22, L2(16), 1400000, 0x03006000},
+  { {1, 1}, 1944000,  ACPU_SCPLL, 0, 0, 1, 0x24, L2(16), 1500000, 0x03006000},
   { {0, 0}, 0 },
 };
 /* acpu_freq_tbl row to use when reconfiguring SC/L2 PLLs. */
@@ -231,6 +233,31 @@
 static struct clkctl_l2_speed *l2_freq_tbl;
 static unsigned int l2_freq_tbl_size;
 
+void acpuclk_get_voltages(unsigned int acpu_freq_vlt_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		acpu_freq_vlt_tbl[i] = f->vdd_sc;
+		i++;
+	}
+
+}
+EXPORT_SYMBOL(acpuclk_get_voltages);
+
+void acpuclk_set_voltages(unsigned int acpu_freq_vlt_tbl[])
+{
+        int i=0;
+        struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		f->vdd_sc = acpu_freq_vlt_tbl[i];
+		i++;
+	}
+}
+EXPORT_SYMBOL(acpuclk_set_voltages);
+
 unsigned long acpuclk_get_rate(int cpu)
 {
 	return drv_state.current_speed[cpu]->acpuclk_khz;
@@ -779,7 +808,7 @@
 
 void __init msm_acpu_clock_init(struct msm_acpu_clock_platform_data *clkdata)
 {
-	unsigned int max_cpu_khz;
+//	unsigned int max_cpu_khz;
 	int cpu;
 
 	mutex_init(&drv_state.lock);
@@ -788,7 +817,11 @@
 	drv_state.vdd_switch_time_us = clkdata->vdd_switch_time_us;
 
 	/* Configure hardware. */
-	max_cpu_khz = select_freq_plan();
+//	max_cpu_khz = select_freq_plan();
+	acpu_freq_tbl = acpu_freq_tbl_v2;
+	l2_freq_tbl = l2_freq_tbl_v2;
+	l2_freq_tbl_size = ARRAY_SIZE(l2_freq_tbl_v2);
+
 	unselect_scplls();
 	scpll_set_refs();
 	for_each_possible_cpu(cpu)
@@ -799,7 +832,7 @@
 
 	/* Improve boot time by ramping up CPUs immediately. */
 	for_each_online_cpu(cpu)
-		acpuclk_set_rate(cpu, max_cpu_khz, SETRATE_INIT);
+		acpuclk_set_rate(cpu, 1188000, SETRATE_INIT);
 
 	cpufreq_table_init();
 }
--- a/drivers/base/cpu.c	2010-08-01 18:11:14.000000000 -0400
+++ b/drivers/base/cpu.c	2011-09-03 20:22:29.000000000 -0400
@@ -14,6 +14,8 @@
 
 #include "base.h"
 
+bool cpufreq_override_tm(void);
+
 static struct sysdev_class_attribute *cpu_sysdev_class_attrs[];
 
 struct sysdev_class cpu_sysdev_class = {
@@ -40,11 +42,16 @@
 	ssize_t ret;
 
 	cpu_hotplug_driver_lock();
+	//printk("CPU SNOOP: process \"%s\" set cpu: %s\n",current->comm,buf[0] == '0' ? "off" : "on");
 	switch (buf[0]) {
 	case '0':
-		ret = cpu_down(cpu->sysdev.id);
-		if (!ret)
-			kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+		if(cpufreq_override_tm()) {
+			ret = cpu_down(cpu->sysdev.id);
+			if (!ret)
+				kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+		}
+		else
+			ret = 0;
 		break;
 	case '1':
 		ret = cpu_up(cpu->sysdev.id);
--- a/drivers/cpufreq/cpufreq_override.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/cpufreq/cpufreq_override.c	2011-09-05 21:49:40.000000000 -0400
@@ -0,0 +1,269 @@
+/*
+ *  drivers/cpufreq/cpufreq_override.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/cpu.h>
+#include <linux/sysfs.h>
+#include <linux/cpufreq.h>
+#include <linux/jiffies.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/kernel_stat.h>
+
+// Voltage min
+#define VDD_MIN 800000
+
+// Voltage max
+#define VDD_MAX 1600000
+
+// Freq count
+#define NR_FREQS 21
+
+// Power saving mode
+#define POWERSAVE 0
+
+// CPU load ramp up percent
+#define RAMPUP_PERCENT 20
+
+// CPU load poll jiffies
+#define POLL_FREQ 100
+
+void acpuclk_get_voltages(unsigned int acpu_freq_vlt_tbl[]);
+void acpuclk_set_voltages(unsigned int acpu_freq_vlt_tbl[]);
+static void check_load(struct work_struct *work);
+
+static DECLARE_DELAYED_WORK(worker, check_load);
+
+bool power_save = POWERSAVE;
+
+static cputime64_t prev_cpu_wall = 0, prev_cpu_idle = 0;
+static unsigned int time_in_state = 0;
+
+static cputime64_t get_cpu_idle_time(unsigned int cpu)
+{
+        cputime64_t idle_time;
+        cputime64_t cur_jiffies;
+        cputime64_t busy_time;
+
+        cur_jiffies = jiffies64_to_cputime64(get_jiffies_64());
+        busy_time = cputime64_add(kstat_cpu(cpu).cpustat.user,
+                                  kstat_cpu(cpu).cpustat.system);
+
+        busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.irq);
+        busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.softirq);
+        busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.steal);
+
+        idle_time = cputime64_sub(cur_jiffies, busy_time);
+        return idle_time;
+}
+
+static unsigned int cur_load(void)
+{
+        unsigned int tmp_idle_ticks, idle_ticks, total_ticks, load = 0, ret = 0;
+        cputime64_t total_idle_ticks, cur_jiffies;
+
+        idle_ticks = UINT_MAX;
+        cur_jiffies = jiffies64_to_cputime64(get_jiffies_64());
+        total_ticks = (unsigned int)cputime64_sub(cur_jiffies, prev_cpu_wall);
+        prev_cpu_wall = get_jiffies_64();
+
+        if (!total_ticks)
+                goto out;
+
+        total_idle_ticks = get_cpu_idle_time(0);
+        tmp_idle_ticks = (unsigned int)cputime64_sub(total_idle_ticks,
+                                                     prev_cpu_idle);
+        prev_cpu_idle = total_idle_ticks;
+
+        if (tmp_idle_ticks < idle_ticks)
+                idle_ticks = tmp_idle_ticks;
+        if (likely(total_ticks > idle_ticks))
+                load = (100 * (total_ticks - idle_ticks)) / total_ticks;
+
+	ret = load;
+
+out:
+	return ret;
+}
+
+bool cpufreq_override_tm(void)
+{
+	return power_save;
+}
+EXPORT_SYMBOL(cpufreq_override_tm);
+
+static void check_load(struct work_struct *work)
+{
+	struct sys_device *dev;
+	unsigned int load = 0;
+
+	load=cur_load();
+
+	if(cpu_online(1)) time_in_state++;
+
+	if(load > RAMPUP_PERCENT) {
+		if(!cpu_online(1)) {
+			cpu_hotplug_driver_lock();
+			dev = get_cpu_sysdev(1);
+			if(!cpu_up(1))
+				kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+			cpu_hotplug_driver_unlock();
+			time_in_state = 0;
+		}
+	}
+	else {
+		if(cpu_online(1) && (time_in_state > 3)) {
+			cpu_hotplug_driver_lock();
+			dev = get_cpu_sysdev(1);
+			if(!cpu_down(1))
+				kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+			cpu_hotplug_driver_unlock();
+			time_in_state = 0;
+		}
+	}
+
+	schedule_delayed_work(&worker, POLL_FREQ);
+}
+
+static ssize_t show_vdd_max(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+        return sprintf(buf, "%u\n", VDD_MAX);
+}
+
+static ssize_t show_vdd_min(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+        return sprintf(buf, "%u\n", VDD_MIN);
+}
+
+static ssize_t show_vdd(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	unsigned int i, acpu_freq_vlt_tbl[NR_FREQS];
+	char tmp[200];
+
+	acpuclk_get_voltages(acpu_freq_vlt_tbl);
+
+	strcpy(buf,"");
+
+	for(i=0 ; i < NR_FREQS ; ++i) {
+		sprintf(tmp,"%u ",acpu_freq_vlt_tbl[i]);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+static ssize_t store_vdd(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int i = 0, acpu_freq_vlt_tbl[NR_FREQS];
+	unsigned int *c = acpu_freq_vlt_tbl;
+
+	// TODO: macro-ize this!
+	i = sscanf(buf, "%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u "
+			"%u %u %u", &c[0],&c[1],&c[2],&c[3],&c[4],&c[5],&c[6],
+				&c[7],&c[8],&c[9],&c[10],&c[11],&c[12],&c[13],
+				&c[14],&c[15],&c[16],&c[17],&c[18],&c[19],&c[20]);
+	if(i != NR_FREQS)
+		printk("override: store_vdd invalid\n");
+	else {
+		for(i=0; i < NR_FREQS ; ++i)
+			if(acpu_freq_vlt_tbl[i] < VDD_MIN || 
+					acpu_freq_vlt_tbl[i] > VDD_MAX) {
+				printk("override: store_vdd vdd %u invalid\n",
+					acpu_freq_vlt_tbl[i]);
+				break;
+			}
+
+		if(i == NR_FREQS) acpuclk_set_voltages(acpu_freq_vlt_tbl);
+	}
+
+	return count;
+}
+
+static ssize_t show_power_saver(struct kobject *kobj, struct attribute *attr,
+                                char *buf)
+{
+        return sprintf(buf,"%u\n",power_save);
+}
+
+static ssize_t store_power_saver(struct kobject *a, struct attribute *b,
+                                const char *buf, size_t count)
+{
+        unsigned int tmp, prev = power_save;
+
+        if(sscanf(buf, "%u", &tmp) == 1) {
+		power_save = (tmp != 0 && tmp != 1) ? power_save : tmp;
+		if(power_save != prev) {
+			if(!prev) cancel_delayed_work(&worker);
+			if(prev) schedule_delayed_work(&worker,10);
+		}
+	}	
+        else
+                printk("override: invalid power save mode\n");
+
+        return count;
+}
+
+define_one_global_ro(vdd_min);
+define_one_global_ro(vdd_max);
+define_one_global_rw(vdd);
+define_one_global_rw(power_saver);
+
+static struct attribute *default_attrs[] = {
+        &vdd.attr,
+	&power_saver.attr,
+        &vdd_min.attr,
+        &vdd_max.attr,
+        NULL
+};
+
+static struct attribute_group override_attr_group = {
+        .attrs = default_attrs,
+        .name = "override"
+};
+
+static int __init cpufreq_override_driver_init(void)
+{
+	schedule_delayed_work(&worker, 10);
+        printk("override: initialized!\n");
+	return sysfs_create_group(cpufreq_global_kobject,&override_attr_group);
+}
+
+static void __exit cpufreq_override_driver_exit(void)
+{
+	cancel_delayed_work(&worker);
+	flush_scheduled_work();
+        sysfs_remove_group(cpufreq_global_kobject, &override_attr_group);
+}
+
+MODULE_AUTHOR("marco@unixpsycho.com");
+MODULE_DESCRIPTION("'cpufreq_override' - A driver to do cool stuff ");
+MODULE_LICENSE("GPL");
+
+module_init(cpufreq_override_driver_init);
+module_exit(cpufreq_override_driver_exit);
+
