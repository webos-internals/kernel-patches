--- a/drivers/cpufreq/Kconfig	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Kconfig	2011-09-24 20:36:04.000000000 -0400
@@ -18,6 +18,19 @@
 config CPU_FREQ_TABLE
 	tristate
 
+config CPU_FREQ_OVERRIDE
+	bool "Enable CPU options override"
+	default y
+	help
+	  Say Y here
+
+config CPU_FREQ_OVERRIDE_L2_HACK
+	bool "Enable overclock L2 freqs"
+	depends on CPU_FREQ_OVERRIDE
+	default n
+	help
+	  Say Y here
+
 config CPU_FREQ_DEBUG
 	bool "Enable CPUfreq debugging"
 	help
--- a/drivers/cpufreq/Makefile	2011-08-02 16:04:21.000000000 -0400
+++ b/drivers/cpufreq/Makefile	2011-08-19 16:12:28.000000000 -0400
@@ -10,6 +10,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE)	+= cpufreq_ondemand_tickle.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_OVERRIDE)		+= cpufreq_override.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
--- a/arch/arm/mach-msm/acpuclock-8x60.c	2011-08-02 16:04:21.000000000 -0400
+++ b/arch/arm/mach-msm/acpuclock-8x60.c	2011-09-24 21:07:41.000000000 -0400
@@ -231,6 +233,8 @@
 static struct clkctl_l2_speed *l2_freq_tbl;
 static unsigned int l2_freq_tbl_size;
 
+#include "override_plug.c"
+
 unsigned long acpuclk_get_rate(int cpu)
 {
 	return drv_state.current_speed[cpu]->acpuclk_khz;
--- a/drivers/base/cpu.c	2010-08-01 18:11:14.000000000 -0400
+++ b/drivers/base/cpu.c	2011-09-17 16:11:16.000000000 -0400
@@ -37,9 +37,12 @@
 				 const char *buf, size_t count)
 {
 	struct cpu *cpu = container_of(dev, struct cpu, sysdev);
-	ssize_t ret;
+	ssize_t ret = 0;
+
+	goto out;
 
 	cpu_hotplug_driver_lock();
+	//printk("CPU SNOOP: process \"%s\" set cpu: %s\n",current->comm,buf[0] == '0' ? "off" : "on");
 	switch (buf[0]) {
 	case '0':
 		ret = cpu_down(cpu->sysdev.id);
@@ -56,6 +59,7 @@
 	}
 	cpu_hotplug_driver_unlock();
 
+out:
 	if (ret >= 0)
 		ret = count;
 	return ret;
--- a/drivers/cpufreq/cpufreq_override.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/cpufreq/cpufreq_override.c	2011-09-24 20:34:57.000000000 -0400
@@ -0,0 +1,260 @@
+/*
+ *  drivers/cpufreq/cpufreq_override.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/cpu.h>
+#include <linux/sysfs.h>
+#include <linux/cpufreq.h>
+#include <linux/jiffies.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
+#include <linux/string.h>
+#include <linux/kernel_stat.h>
+
+// Voltage min
+#define VDD_MIN 800000
+
+// Voltage max
+#define VDD_MAX 1600000
+
+// Max Freq count. Not the actual number of freqs
+#define MAX_FREQS 35
+
+// Power saving mode
+#define POWERSAVE 0
+
+// L2 Boost mode
+#define L2_BOOST 0
+
+/* ************* end of tunables ***************************************** */
+
+void acpuclk_get_voltages(unsigned int acpu_freq_vlt_tbl[]);
+void acpuclk_set_voltages(unsigned int acpu_freq_vlt_tbl[]);
+unsigned int acpuclk_get_freqs(unsigned int acpu_freq_tbl[]);
+void acpuclk_set_l2_hack(bool state);
+
+static bool power_save = POWERSAVE;
+static bool lcd_state = 1;
+static bool l2boost = L2_BOOST;
+
+static unsigned int freq_table[MAX_FREQS];
+static unsigned int nr_freqs;
+
+bool cpufreq_override_get_lcd_state(void)
+{
+	return power_save ? lcd_state : 1;
+}
+EXPORT_SYMBOL(cpufreq_override_get_lcd_state);
+
+void cpufreq_override_set_lcd_state(bool state)
+{
+	struct sys_device *dev = get_cpu_sysdev(1);
+
+	lcd_state = state;
+	printk("override: lcd state=%u\n",state);
+
+	// If screen is off, take cpu offline if in power save mode
+	if(power_save && !lcd_state) {
+		cpu_hotplug_driver_lock();
+		if(!cpu_down(1)) kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+		cpu_hotplug_driver_unlock();
+	}
+	// force CPU online regardless
+	if(lcd_state) {
+		cpu_hotplug_driver_lock();
+		if(!cpu_up(1)) kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+		cpu_hotplug_driver_unlock();
+	}
+}
+EXPORT_SYMBOL(cpufreq_override_set_lcd_state);
+
+static ssize_t show_vdd_max(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%u\n", VDD_MAX);
+}
+
+static ssize_t show_vdd_min(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%u\n", VDD_MIN);
+}
+
+static ssize_t show_vdd(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	unsigned int i, acpu_freq_vlt_tbl[MAX_FREQS];
+	char tmp[250];
+
+	acpuclk_get_voltages(acpu_freq_vlt_tbl);
+
+	strcpy(buf,"");
+
+	for(i=0 ; i < nr_freqs ; ++i) {
+		sprintf(tmp,"%u ",acpu_freq_vlt_tbl[i]);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+static ssize_t store_vdd(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int i = 0, acpu_freq_vlt_tbl[MAX_FREQS];
+	unsigned int *c = acpu_freq_vlt_tbl;
+	const char *wp = buf;
+
+	for(i = 0; i < nr_freqs; i++) {
+		wp=skip_spaces(wp);
+		sscanf(wp,"%u",&c[i]);
+		if(c[i] < VDD_MIN || c[i] > VDD_MAX) break;
+		wp=strchr(wp,' ')+1;
+  	}
+
+	if(i != nr_freqs)
+		printk("override: store_vdd invalid\n");
+	else
+		acpuclk_set_voltages(acpu_freq_vlt_tbl);
+
+	return count;
+}
+
+static ssize_t show_power_saver(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf,"%u\n",power_save);
+}
+
+static ssize_t store_power_saver(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int tmp;
+
+	if(sscanf(buf, "%u", &tmp) == 1) {
+		power_save = (tmp != 0 && tmp != 1) ? power_save : tmp;
+	}	
+	else
+		printk("override: invalid power save mode\n");
+
+	return count;
+}
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+static ssize_t show_l2_boost(struct kobject *kobj, struct attribute *attr,
+				char *buf)
+{
+	return sprintf(buf,"%u\n",l2boost);
+}
+
+static ssize_t store_l2_boost(struct kobject *a, struct attribute *b,
+				const char *buf, size_t count)
+{
+	unsigned int tmp;
+
+	if(sscanf(buf, "%u", &tmp) == 1) {
+		l2boost = (tmp != 0 && tmp != 1) ? l2boost : tmp;
+		if(l2boost) acpuclk_set_l2_hack(1);
+		else acpuclk_set_l2_hack(0);
+	}       
+	else
+		printk("override: invalid l2 boost mode\n");
+
+	return count;
+}
+#endif
+
+static ssize_t show_available_freqs(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	unsigned int i;
+	char tmp[250];
+
+	strcpy(buf,"");
+
+	for(i=0 ; i < nr_freqs ; ++i) {
+		sprintf(tmp,"%u ", freq_table[i]);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+define_one_global_ro(vdd_min);
+define_one_global_ro(vdd_max);
+define_one_global_ro(available_freqs);
+define_one_global_rw(vdd);
+define_one_global_rw(power_saver);
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+define_one_global_rw(l2_boost);
+#endif
+
+static struct attribute *default_attrs[] = {
+	&vdd.attr,
+	&available_freqs.attr,
+	&power_saver.attr,
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+	&l2_boost.attr,
+#endif
+	&vdd_min.attr,
+	&vdd_max.attr,
+	NULL
+};
+
+static struct attribute_group override_attr_group = {
+	.attrs = default_attrs,
+	.name = "override"
+};
+
+static int __init cpufreq_override_driver_init(void)
+{
+
+	// not sure why cpufreq_frequency_get_table doesnt work here
+	nr_freqs = acpuclk_get_freqs(freq_table);
+
+	printk("override: freqs configured: %u\n",nr_freqs);
+
+/*	for(i = 0; (table[i].frequency |= CPUFREQ_TABLE_END); i++) {
+		if (table[i].frequency == CPUFREQ_ENTRY_INVALID) continue;
+		freq_table[i] = table[i].frequency;
+	}
+
+	nr_freqs = table[i].index; */
+
+	printk("override: initialized!\n");
+
+	return sysfs_create_group(cpufreq_global_kobject,&override_attr_group);
+}
+
+static void __exit cpufreq_override_driver_exit(void)
+{
+	sysfs_remove_group(cpufreq_global_kobject, &override_attr_group);
+}
+
+MODULE_AUTHOR("marco@unixpsycho.com");
+MODULE_DESCRIPTION("'cpufreq_override' - A driver to do cool stuff ");
+MODULE_LICENSE("GPL");
+
+module_init(cpufreq_override_driver_init);
+module_exit(cpufreq_override_driver_exit);
+
--- a/arch/arm/mach-msm/override_plug.c	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-msm/override_plug.c	2011-09-24 20:45:59.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ *  override_plug.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_L2_HACK
+
+// define L2 overclock table indexes from l2_freq_tbl_v2 L2(x)
+//  set it the same to render it useless
+#define L2_OCLK_IDX 17
+#define L2_NORM_IDX 16
+
+// Minimum LVAL freq for L2 overclock 54 MHz * L_VAL
+#define MIN_LVAL_L2 0x20
+
+void acpuclk_set_l2_hack(bool state)
+{
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2 + 7; f->acpuclk_khz != 0; f++) {
+		if(f->use_for_scaling[0] == 0) continue;
+		if(f->l_val < MIN_LVAL_L2) continue;
+		f->l2_level = (state) ? L2(L2_OCLK_IDX) : L2(L2_NORM_IDX);
+	}
+}
+EXPORT_SYMBOL(acpuclk_set_l2_hack);
+#endif
+
+void acpuclk_get_voltages(unsigned int acpu_freq_vlt_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		if(f->use_for_scaling[0] == 0) continue;
+		acpu_freq_vlt_tbl[i] = f->vdd_sc;
+		i++;
+	}
+
+}
+EXPORT_SYMBOL(acpuclk_get_voltages);
+
+void acpuclk_set_voltages(unsigned int acpu_freq_vlt_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		if(f->use_for_scaling[0] == 0) continue;
+		f->vdd_sc = acpu_freq_vlt_tbl[i];
+		i++;
+	}
+}
+EXPORT_SYMBOL(acpuclk_set_voltages);
+
+unsigned int acpuclk_get_freqs(unsigned int acpu_freq_tbl[])
+{
+	int i=0;
+	struct clkctl_acpu_speed *f;
+
+	for (f = acpu_freq_tbl_v2; f->acpuclk_khz != 0; f++) {
+		if(!f->use_for_scaling[0]) continue;
+		acpu_freq_tbl[i] = f->acpuclk_khz;
+		i++;
+	}
+
+	return i;
+}
+EXPORT_SYMBOL(acpuclk_get_freqs);
--- a/drivers/video/msm_pe/msm_fb.c	2011-08-02 16:04:22.000000000 -0400
+++ b/drivers/video/msm_pe/msm_fb.c	2011-09-18 12:53:30.000000000 -0400
@@ -51,6 +51,8 @@
 #include "mdp.h"
 #include "mdp4.h"
 
+void cpufreq_override_set_lcd_state(bool state);
+
 #ifdef CONFIG_FB_MSM_LOGO
 #define INIT_IMAGE_FILE "/initlogo.rle"
 extern int load_565rle_image(char *filename);
@@ -354,6 +356,8 @@
 			//fb_set_suspend(mfd->fbi[0], FBINFO_STATE_RUNNING);
 
 			mfd->suspended = false;
+
+                        cpufreq_override_set_lcd_state(1);
 		}
 
 	}
@@ -374,6 +378,8 @@
 				//fb_set_suspend(mfd->fbi[0], FBINFO_STATE_SUSPENDED);
 				mfd->pdev->dev.power.power_state = PMSG_SUSPEND;
 				mfd->suspended = true;
+
+                                cpufreq_override_set_lcd_state(0);
 			}
 		}
 
--- a/kernel/cpu.c	2011-08-02 16:04:22.000000000 -0400
+++ b/kernel/cpu.c	2011-09-18 12:56:48.000000000 -0400
@@ -41,6 +41,8 @@
  */
 static int cpu_hotplug_disabled;
 
+bool cpufreq_override_get_lcd_state(void);
+
 #ifdef CONFIG_HOTPLUG_CPU
 
 static struct {
@@ -201,6 +203,7 @@
 	unsigned int cpu = (unsigned long)param->hcpu;
 	int err;
 
+	if(cpufreq_override_get_lcd_state()) goto out;
 	/* Ensure this CPU doesn't handle any more interrupts. */
 	err = __cpu_disable();
 	if (err < 0)
@@ -213,6 +216,7 @@
 	/* Force idle task to run as soon as we yield: it should
 	   immediately notice cpu is offline and die quickly. */
 	sched_idle_next();
+out:
 	return 0;
 }
 
@@ -234,6 +238,11 @@
 	if (!cpu_online(cpu))
 		return -EINVAL;
 
+	if (cpufreq_override_get_lcd_state()) {
+		err= -EINVAL;
+		goto out;
+	}
+
 	cpu_hotplug_begin();
 	set_cpu_active(cpu, false);
 	err = __cpu_notify(CPU_DOWN_PREPARE | mod, hcpu, -1, &nr_calls);
@@ -279,6 +288,7 @@
 	cpu_hotplug_done();
 	if (!err)
 		cpu_notify_nofail(CPU_POST_DEAD | mod, hcpu);
+out:
 	return err;
 }
 
@@ -383,7 +393,7 @@
 
 	cpu_maps_update_begin();
 
-	if (cpu_hotplug_disabled) {
+	if (cpu_hotplug_disabled || !cpufreq_override_get_lcd_state()) {
 		err = -EBUSY;
 		goto out;
 	}
