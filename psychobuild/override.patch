--- a/drivers/cpufreq/Kconfig	2011-11-06 11:44:37.000000000 -0500
+++ b/drivers/cpufreq/Kconfig	2011-11-06 14:07:27.000000000 -0500
@@ -18,6 +18,19 @@
 config CPU_FREQ_TABLE
 	tristate
 
+config CPU_FREQ_OVERRIDE
+        bool "Enable CPU options override"
+        default y
+        help
+          Say Y here
+
+config CPU_FREQ_OVERRIDE_VOLT_CONFIG
+        bool "Enable CPU voltage tweaking"
+        depends on CPU_FREQ_OVERRIDE
+        default y
+        help
+          Say Y here
+
 config CPU_FREQ_DEBUG
 	bool "Enable CPUfreq debugging"
 	help
--- a/drivers/cpufreq/Makefile	2011-11-06 11:44:37.000000000 -0500
+++ b/drivers/cpufreq/Makefile	2011-11-06 14:08:43.000000000 -0500
@@ -11,6 +11,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE)	+= cpufreq_ondemand_tickle.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
 obj-$(CONFIG_CPU_FREQ_GOV_SCREEN)	+= cpufreq_screen.o
+obj-$(CONFIG_CPU_FREQ_OVERRIDE)		+= cpufreq_override.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
--- a/drivers/cpufreq/cpufreq.c	2011-11-06 11:44:37.000000000 -0500
+++ b/drivers/cpufreq/cpufreq.c	2011-11-06 15:45:39.000000000 -0500
@@ -33,6 +33,11 @@
 #define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_CORE, \
 						"cpufreq-core", msg)
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+int cpufreq_override_driver_init(void);
+void cpufreq_override_driver_exit(void);
+#endif
+
 /**
  * The "cpufreq driver" - the arch- or hardware-dependent low
  * level driver of CPUFreq support, and its spinlock. This lock
@@ -1881,6 +1886,10 @@
 		cpufreq_debug_enable_ratelimit();
 	}
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+        cpufreq_override_driver_init();
+#endif
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(cpufreq_register_driver);
@@ -1914,6 +1923,10 @@
 	cpufreq_driver = NULL;
 	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+        cpufreq_override_driver_exit();
+#endif
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(cpufreq_unregister_driver);
--- a/arch/arm/mach-msm/acpuclock-7x30.c	2011-11-06 11:44:37.000000000 -0500
+++ b/arch/arm/mach-msm/acpuclock-7x30.c	2011-11-06 17:30:01.000000000 -0500
@@ -388,3 +399,6 @@
 	cpufreq_frequency_table_get_attr(freq_table, smp_processor_id());
 #endif
 }
+
+#include "override_plug.c"
+
--- a/drivers/cpufreq/cpufreq_override.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/cpufreq/cpufreq_override.c	2011-11-06 15:44:11.000000000 -0500
@@ -0,0 +1,188 @@
+/*
+ *  drivers/cpufreq/cpufreq_override.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/cpu.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
+#include <linux/string.h>
+#include <linux/kernel_stat.h>
+#include <linux/cpufreq.h>
+
+// Voltage min
+#define VDD_MIN 800000
+
+// Voltage max
+#define VDD_MAX 1500000
+
+// Max Freq count. Not the actual number of freqs
+#define MAX_FREQS 35
+
+/* ************* end of tunables ***************************************** */
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+void acpuclk_get_voltages(unsigned int acpu_freqs_vlt_tbl[]);
+void acpuclk_set_voltages(unsigned int acpu_freqs_vlt_tbl[]);
+#endif
+
+unsigned int acpuclk_get_freqs(unsigned int acpu_freqs_tbl[]);
+static unsigned int freq_table[MAX_FREQS];
+static unsigned int nr_freqs;
+
+#define define_one_ro(_name)                            \
+static struct freq_attr _name =                         \
+__ATTR(_name, 0444, show_##_name, NULL)
+
+#define define_one_rw(_name) \
+static struct freq_attr _name = \
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
+char *skip_spaces(const char *str)
+{
+        while (*str == ' ' || *str == '\t')
+                ++str;
+        return (char *)str;
+}
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+static ssize_t show_vdd_max(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", VDD_MAX);
+}
+
+static ssize_t show_vdd_min(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", VDD_MIN);
+}
+
+static ssize_t show_vdd(struct cpufreq_policy *policy, char *buf)
+{
+	unsigned int i, acpu_freq_vlt_tbl[MAX_FREQS];
+	char tmp[250];
+
+	acpuclk_get_voltages(acpu_freq_vlt_tbl);
+
+	strcpy(buf,"");
+
+	for(i=0 ; i < nr_freqs ; ++i) {
+		sprintf(tmp,"%u ",acpu_freq_vlt_tbl[i] * 1000);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+static ssize_t store_vdd(struct cpufreq_policy *a,const char *buf,size_t count)
+{
+	unsigned int i = 0, acpu_freq_vlt_tbl[MAX_FREQS];
+	unsigned int *c = acpu_freq_vlt_tbl;
+	const char *wp = buf;
+
+	for(i = 0; i < nr_freqs; i++) {
+		wp=skip_spaces(wp);
+		sscanf(wp,"%u",&c[i]);
+		if(c[i] < VDD_MIN || c[i] > VDD_MAX) break;
+		c[i] /= 1000;
+		wp=strchr(wp,' ')+1;
+  	}
+
+	if(i != nr_freqs)
+		printk("override: store_vdd invalid\n");
+	else {
+		acpuclk_set_voltages(acpu_freq_vlt_tbl);
+
+		printk("override: set vdd %s\n",buf);
+	}
+
+	return count;
+}
+#endif
+
+static ssize_t show_vdd_freqs(struct cpufreq_policy *policy, char *buf)
+{
+	unsigned int i;
+	char tmp[250];
+
+	*buf='\0';
+	*tmp='\0';
+
+	for(i=0 ; i < nr_freqs ; ++i) {
+		sprintf(tmp,"%u ", freq_table[i]);
+		strcat(buf,tmp);
+	}
+
+	strcpy(tmp,buf);
+
+	return sprintf(buf,"%s\n",tmp);
+}
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+define_one_ro(vdd_min);
+define_one_ro(vdd_max);
+define_one_rw(vdd);
+#endif
+define_one_ro(vdd_freqs);
+
+static struct attribute *default_attrs[] = {
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+	&vdd.attr,
+	&vdd_min.attr,
+	&vdd_max.attr,
+#endif
+	&vdd_freqs.attr,
+	NULL
+};
+
+static struct attribute_group override_attr_group = {
+	.attrs = default_attrs,
+	.name = "override"
+};
+
+void cpufreq_override_driver_init(void)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+	int ret = 0;
+
+	nr_freqs = acpuclk_get_freqs(freq_table);
+	printk("override: freqs configured: %u\n",nr_freqs);
+
+	if(!policy) goto out;
+	if((ret = sysfs_create_group(&policy->kobj, &override_attr_group)))
+		 printk("override: failed!\n");
+	else
+		 printk("override: initialized!\n");
+out:
+	return ret;
+}
+
+void cpufreq_override_driver_exit(void)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+
+	sysfs_remove_group(&policy->kobj, &override_attr_group);
+}
+
+EXPORT_SYMBOL(cpufreq_override_driver_exit);
+EXPORT_SYMBOL(cpufreq_override_driver_init);
--- a/arch/arm/mach-msm/override_plug.c	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-msm/override_plug.c	2011-11-06 14:30:13.000000000 -0500
@@ -0,0 +1,71 @@
+/*
+ *  override_plug.c
+ *
+ *      Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_VOLT_CONFIG
+void acpuclk_get_voltages(unsigned int acpu_freqs_vlt_tbl[])
+{
+	int i=0;
+	struct cpufreq_frequency_table *f;
+	struct clkctl_acpu_speed *v;
+
+	 v = acpu_freq_tbl;
+
+	 for (f = freq_table; f->frequency != CPUFREQ_TABLE_END; f++) {
+		while(v->acpu_clk_khz != f->frequency) v++;
+		if(v->acpu_clk_khz == f->frequency)
+			acpu_freqs_vlt_tbl[i] = v->vdd_mv;
+		else printk("override: BUG!\n");
+		i++;
+	}
+}
+EXPORT_SYMBOL(acpuclk_get_voltages);
+
+void acpuclk_set_voltages(unsigned int acpu_freqs_vlt_tbl[])
+{
+	int i=0;
+	struct cpufreq_frequency_table *f;
+	struct clkctl_acpu_speed *v;
+
+	v = acpu_freq_tbl;
+
+	for (f = freq_table; f->frequency != CPUFREQ_TABLE_END; f++) {
+		while(v->acpu_clk_khz != f->frequency) v++;
+		if(v->acpu_clk_khz == f->frequency)
+			v->vdd_mv = acpu_freqs_vlt_tbl[i];
+		else printk("override: BUG!\n");
+		i++;
+	}
+}
+EXPORT_SYMBOL(acpuclk_set_voltages);
+#endif
+
+unsigned int acpuclk_get_freqs(unsigned int acpu_freqs_tbl[])
+{
+	int i=0;
+ 	struct cpufreq_frequency_table *f;
+
+	for (f = freq_table; f->frequency != CPUFREQ_TABLE_END; f++) {
+		acpu_freqs_tbl[i] = f->frequency;
+		i++;
+	}
+
+	return i;
+}
+EXPORT_SYMBOL(acpuclk_get_freqs);
