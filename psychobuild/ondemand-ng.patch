--- a/drivers/cpufreq/cpufreq_ondemand_tickle.c	2011-10-19 15:40:46.000000000 -0400
+++ b/drivers/cpufreq/cpufreq_ondemand_tickle.c	2011-11-10 22:27:43.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- *  drivers/cpufreq/cpufreq_ondemand_tickle.c
+ *  drivers/cpufreq/cpufreq_ondemandtcl.c
  *
  *  A version of cpufreq_ondemand supporing hinting, or tickling, into
  *  high performance levels based on platform defined events. This governor
@@ -13,6 +13,8 @@
  *                      Jun Nakajima <jun.nakajima@intel.com>
  *            (C)  2009 Palm Inc, Corey Tabaka <corey.tabaka@palm.com>
  *
+ *		Screenstate mod by uNiXpXyChO
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -315,6 +317,30 @@
 	return count;
 }
 
+static bool ss_enabled = 0;
+static unsigned int sleep_max_freq = 432000;
+extern bool msm_fb_state;
+
+static int cpufreq_target(struct cpufreq_policy *policy, unsigned int freq,
+							unsigned int relation)
+{
+	int retval = -EINVAL;
+
+	if(msm_fb_state || !ss_enabled) {
+		retval = __cpufreq_driver_target(policy, freq, relation);
+	}
+	else {
+		if(freq <= sleep_max_freq)
+			retval = __cpufreq_driver_target(policy, freq,
+								relation);
+		else
+			retval = __cpufreq_driver_target(policy, sleep_max_freq,
+								relation);
+	}
+
+	return retval;
+}
+
 static void *stats_start(struct seq_file *m, loff_t *pos)
 {
 	int i;
@@ -773,6 +799,18 @@
 	return sprintf(buf, "%u\n", min_sampling_rate);
 }
 
+static ssize_t show_screen_off_max_freq(struct kobject *kobj,
+					struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", sleep_max_freq);
+}
+ 
+static ssize_t show_screenstate_enable(struct kobject *kobj,
+					struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", ss_enabled);
+}
+
 define_one_global_ro(sampling_rate_max);
 define_one_global_ro(sampling_rate_min);
 
@@ -783,6 +821,7 @@
 {									\
 	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
 }
+
 show_one(sampling_rate, sampling_rate);
 show_one(io_is_busy, io_is_busy);
 show_one(up_threshold, up_threshold);
@@ -993,6 +1032,44 @@
 	return count;
 }
 
+static ssize_t store_screen_off_max_freq(struct kobject *a, struct attribute *b,
+					    const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1)
+		  return -EINVAL;
+
+	if (input < 122880 || input > 2000000) {
+		  printk("ondemandtcl: invalid sleep freq\n");
+		  return -EINVAL;
+	}
+
+	sleep_max_freq = input;
+
+	return count;
+}
+
+static ssize_t store_screenstate_enable(struct kobject *a, struct attribute *b,
+						const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret; 
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1)
+		  return -EINVAL;
+
+	if (input != 0 && input != 1) {
+		  return -EINVAL;
+	}
+
+	ss_enabled = input;
+
+	return count;
+}
 
 define_one_global_rw(sampling_rate);
 define_one_global_rw(io_is_busy);
@@ -1002,6 +1079,8 @@
 define_one_global_rw(ignore_nice_load);
 define_one_global_rw(powersave_bias);
 define_one_global_rw(max_tickle_window);
+define_one_global_rw(screen_off_max_freq);
+define_one_global_rw(screenstate_enable);
 
 static struct attribute *dbs_attributes[] = {
 	&sampling_rate_max.attr,
@@ -1014,6 +1093,8 @@
 	&powersave_bias.attr,
 	&io_is_busy.attr,
 	&max_tickle_window.attr,
+	&screen_off_max_freq.attr,
+	&screenstate_enable.attr,
 	NULL
 };
 
@@ -1075,7 +1156,7 @@
 	else if (p->cur == p->max)
 		return;
 
-	__cpufreq_driver_target(p, freq, dbs_tuners_ins.powersave_bias ?
+	cpufreq_target(p, freq, dbs_tuners_ins.powersave_bias ?
 			CPUFREQ_RELATION_L : CPUFREQ_RELATION_H);
 }
 
@@ -1173,7 +1254,7 @@
 				if (policy->cur < policy->max) {
 					record_sample(policy->cur, policy->max,
 						 -21, policy->cpu, NULL);
-					__cpufreq_driver_target(policy, policy->max, CPUFREQ_RELATION_H);
+					cpufreq_target(policy, policy->max, CPUFREQ_RELATION_H);
 				}
 
 				dbs_info->tickle_active = 1;
@@ -1383,7 +1464,7 @@
 				if (policy->cur < f) {
 					record_sample(policy->cur, f, -31,
 						policy->cpu, NULL);
-					__cpufreq_driver_target(policy, f,
+					cpufreq_target(policy, f,
 						CPUFREQ_RELATION_L);
 				}
 
@@ -1697,7 +1778,7 @@
 
 			record_sample(policy->cur, policy->max, load,
 				policy->cpu, &this_dbs_info->rlv);
-			__cpufreq_driver_target(policy, policy->max,
+			cpufreq_target(policy, policy->max,
 				CPUFREQ_RELATION_H);
 		} else {
 			int freq = powersave_bias_target(policy, policy->max,
@@ -1711,7 +1792,7 @@
 			if (policy->cur != freq)
 				record_sample(policy->cur, freq, load,
 					policy->cpu, &this_dbs_info->rlv);
-			__cpufreq_driver_target(policy, freq,
+			cpufreq_target(policy, freq,
 				CPUFREQ_RELATION_L);
 		}
 		return;
@@ -1750,7 +1831,7 @@
 			if (policy->cur != freq_next)
 				record_sample(policy->cur, freq_next, load,
 					policy->cpu, &this_dbs_info->rlv);
-			__cpufreq_driver_target(policy, freq_next,
+			cpufreq_target(policy, freq_next,
 					CPUFREQ_RELATION_L);
 		} else {
 			int freq = powersave_bias_target(policy, freq_next,
@@ -1763,7 +1844,7 @@
 			if (policy->cur != freq)
 				record_sample(policy->cur, freq, load,
 					policy->cpu, &this_dbs_info->rlv);
-			__cpufreq_driver_target(policy, freq,
+			cpufreq_target(policy, freq,
 				CPUFREQ_RELATION_L);
 		}
 	}
@@ -1799,7 +1880,7 @@
 	} else {
 		record_sample(dbs_info->cur_policy->cur, dbs_info->freq_lo,
 			-1, cpu, NULL);
-		__cpufreq_driver_target(dbs_info->cur_policy,
+		cpufreq_target(dbs_info->cur_policy,
 			dbs_info->freq_lo, CPUFREQ_RELATION_H);
 	}
 	queue_delayed_work_on(cpu, kondemand_wq, &dbs_info->work, delay);
@@ -1894,8 +1975,7 @@
 		record_sample(policy->cur, policy->max, -51, policy->cpu, NULL);
 		policy->cur = policy->max;
 
-		__cpufreq_driver_target(policy, policy->max,
-					CPUFREQ_RELATION_L);
+		cpufreq_target(policy, policy->max, CPUFREQ_RELATION_L);
 		this_dbs_info->prev_cpu_idle = get_cpu_idle_time(0,
 				&this_dbs_info->prev_cpu_wall);
 	}
@@ -2165,13 +2245,13 @@
 		if (policy->max < this_dbs_info->cur_policy->cur) {
 			record_sample(policy->cur, policy->max, -40,
 				policy->cpu, NULL);
-			__cpufreq_driver_target(this_dbs_info->cur_policy,
+			cpufreq_target(this_dbs_info->cur_policy,
 			                        policy->max,
 			                        CPUFREQ_RELATION_H);
 		} else if (policy->min > this_dbs_info->cur_policy->cur) {
 			record_sample(policy->cur, policy->min, -41,
 				policy->cpu, NULL);
-			__cpufreq_driver_target(this_dbs_info->cur_policy,
+			cpufreq_target(this_dbs_info->cur_policy,
 			                        policy->min,
 			                        CPUFREQ_RELATION_L);
 		}
@@ -2260,7 +2340,8 @@
 MODULE_AUTHOR("Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>");
 MODULE_AUTHOR("Corey Tabaka <corey.tabaka@palm.com>");
 MODULE_DESCRIPTION("'cpufreq_ondemand_tickle' - A dynamic cpufreq governor for "
-                   "Low Latency Frequency Transition capable processors");
+                   "Low Latency Frequency Transition capable processors"
+                   "With Screenstate");
 MODULE_LICENSE("GPL");
 
 #ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND_TICKLE
--- a/drivers/video/msm_pe/msm_fb.c	2011-10-19 15:40:47.000000000 -0400
+++ b/drivers/video/msm_pe/msm_fb.c	2011-11-10 22:11:24.000000000 -0500
@@ -68,6 +72,11 @@
 
 int vsync_mode = 1;
 
+#ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE
+bool msm_fb_state=1;
+EXPORT_SYMBOL(msm_fb_state);
+#endif
+
 #define MAX_BLIT_REQ 256
 
 #define MAX_FBI_LIST 32
@@ -347,6 +356,9 @@
 		}
 		else {
 			printk(KERN_INFO "msmfb: Resuming msmfb\n");
+#ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE
+			msm_fb_state=1;
+#endif
 			acquire_console_sem();
 			ret = msm_fb_resume_sub(mfd);
 			release_console_sem();
@@ -364,6 +380,9 @@
 		}
 		else {
 			printk(KERN_INFO "msmfb: Suspending msmfb\n");
+#ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_TICKLE
+			msm_fb_state=0;
+#endif
 			acquire_console_sem();
 			ret = msm_fb_suspend_sub(mfd);
 			release_console_sem();
