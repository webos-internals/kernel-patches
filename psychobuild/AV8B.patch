--- linux-2.6.24-palm/drivers/cpufreq/Kconfig	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/cpufreq/Kconfig	2011-03-03 16:09:44.000000000 -0500
@@ -53,6 +53,23 @@
 
 	  If in doubt, say N.
 
+config CPU_FREQ_OVERRIDE
+	bool "Extra on-demand CPU tweaking options"
+	default y
+	help
+	  This will give options to tweak CPU settings in-demand.
+
+	  If in doubt, say Y.
+
+config CPU_FREQ_OVERRIDE_STRIPOPP
+	bool "Strip OPP1 and OPP2 from available frequencies list"
+	depends on CPU_FREQ_OVERRIDE
+	default y
+	help
+	  This will hide 125MHz and 250MHz from scaling_available_frequencies.
+
+	  If in doubt, say N.
+
 choice
 	prompt "Default CPUFreq governor"
 	default CPU_FREQ_DEFAULT_GOV_USERSPACE if CPU_FREQ_SA1100 || CPU_FREQ_SA1110
@@ -87,6 +104,13 @@
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
+config CPU_FREQ_DEFAULT_GOV_VDEMAND
+	bool "vdemand"
+	select CPU_FREQ_GOV_VDEMAND
+	help
+	  Use the CPUFreq governor 'vdemand' as default. This will
+	  scale the CPU up and down depending on load.
+
 config CPU_FREQ_DEFAULT_GOV_ONDEMAND
 	bool "ondemand"
 	select CPU_FREQ_GOV_ONDEMAND
@@ -149,6 +173,17 @@
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_GOV_VDEMAND
+	tristate "'vdemand' governor for frequency scaling"
+	help
+	  Enable this cpufreq governor to scale CPU voltage.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_vdemand.
+
+	  If in doubt, say Y.
+
+
 config CPU_FREQ_GOV_ONDEMAND
 	tristate "'ondemand' cpufreq policy governor"
 	select CPU_FREQ_TABLE
--- linux-2.6.24-palm/drivers/cpufreq/Makefile	2008-01-24 17:58:37.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/cpufreq/Makefile	2011-03-03 16:09:44.000000000 -0500
@@ -9,7 +9,11 @@
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_VDEMAND)	+= cpufreq_vdemand.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
 
+# CPUfreq override
+obj-$(CONFIG_CPU_FREQ_OVERRIDE)         += cpufreq_override.o
+
--- linux-2.6.24-palm/drivers/cpufreq/cpufreq.c	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/cpufreq/cpufreq.c	2011-05-18 00:13:02.000000000 -0400
@@ -32,6 +32,11 @@
 #define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_CORE, \
 						"cpufreq-core", msg)
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+int cpufreq_override_driver_init(void);
+void cpufreq_override_driver_exit(void);
+#endif
+
 /**
  * The "cpufreq driver" - the arch- or hardware-dependent low
  * level driver of CPUFreq support, and its spinlock. This lock
@@ -1682,6 +1687,18 @@
 	return ret;
 }
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+int cpufreq_set_policy(struct cpufreq_policy *policy)
+{
+	struct cpufreq_policy *data = cpufreq_cpu_get(0);
+	__cpufreq_set_policy(data,policy);
+	data->user_policy.min = data->min;
+	data->user_policy.max = data->max;
+	cpufreq_cpu_put(data);
+}
+EXPORT_SYMBOL(cpufreq_set_policy);
+#endif
+
 /**
  *	cpufreq_update_policy - re-evaluate an existing cpufreq policy
  *	@cpu: CPU which shall be re-evaluated
@@ -1831,6 +1848,10 @@
 		cpufreq_debug_enable_ratelimit();
 	}
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+	cpufreq_override_driver_init();
+#endif
+
 	return (ret);
 }
 EXPORT_SYMBOL_GPL(cpufreq_register_driver);
@@ -1864,6 +1885,10 @@
 	cpufreq_driver = NULL;
 	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+	cpufreq_override_driver_exit();
+#endif
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(cpufreq_unregister_driver);
--- linux-2.6.24-palm/include/linux/cpufreq.h	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/include/linux/cpufreq.h	2011-03-03 16:09:44.000000000 -0500
@@ -309,6 +309,9 @@
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_userspace)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_VDEMAND)
+extern struct cpufreq_governor cpufreq_gov_vdemand;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_vdemand)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND)
 extern struct cpufreq_governor cpufreq_gov_ondemand;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_ondemand)
--- linux-2.6.24-palm/arch/arm/mach-omap3pe/prcm_opp.c	2011-02-28 17:03:31.000000000 -0500
+++ linux-2.6.24-AV8B/arch/arm/mach-omap3pe/prcm_opp.c	2011-05-25 22:49:25.000000000 -0400
@@ -57,7 +57,7 @@
 static u8 mpu_iva2_vdd1_volts [PRCM_NO_VDD1_OPPS] = {
 	/* Vsel corresponding to 0.975V (OPP1), 1.050V (OPP2),
 				1.20V (OPP3), 1.27V (OPP4), 1.35 (OPP5) */
-	0x1e, 0x24, 0x30, 0x36, 0x3C
+	0x1e, 0x24, 0x30, 0x42, 0x44
 };
 
 static u8 core_l3_vdd2_volts [PRCM_NO_VDD2_OPPS] = { /* only 3 OPPs */
@@ -138,7 +138,7 @@
 
 u32 omap3_max_vdd1_opp(void)
 {
-	return 5;
+	return 0;
 
 	/* This function call is used in the bridgedriver.
 	 *
@@ -191,10 +191,10 @@
 	/* 13M values */
 	/* OPP1(125 Mhz) and OPP2(250 Mhz)*/
 	{{0x1F4, 0x0C, 0x03, 0x04}, {0x1F4, 0x0C, 0x03, 0x02},
-	/* OPP3(500 Mhz) and OPP4(550 Mhz)*/
-	{0x1F4, 0x0C, 0x03, 0x01}, {0x226, 0x0C, 0x03, 0x01},
-	/* OPP5 (600 Mhz) */
-	{0x258, 0x0C, 0x03, 0x01} },
+	/* OPP3(500 Mhz) and OPP4(800 Mhz)*/
+	{0x1F4, 0x0C, 0x03, 0x01}, {0x320, 0x0C, 0x03, 0x01},
+	/* OPP5 (1005 Mhz) */
+	{0x3ED, 0x0C, 0x03, 0x01} },
 	/* 19.2M values */
 	/* OPP1(125 Mhz) and OPP2(250 Mhz)*/
 	{{0x271, 0x17, 0x03, 0x04}, {0x271, 0x17, 0x03, 0x02},
@@ -230,10 +230,10 @@
 	/* 13M values */
 	/* OPP1(90 Mhz) and OPP2(180 Mhz)*/
 	{{0x168, 0x0C, 0x03, 0x04}, {0x168, 0x0C, 0x03, 0x02},
-	/* OPP3(360 Mhz) and OPP4(400 Mhz)*/
-	 {0x168, 0x0C, 0x03, 0x01}, {0x190, 0x0C, 0x03, 0x01},
-	/* OPP5 (430 Mhz) */
-	 {0x1AE, 0x0C, 0x03, 0x01} },
+	/* OPP3(360 Mhz) and OPP4(360 Mhz)*/
+	 {0x168, 0x0C, 0x03, 0x01}, {0x168, 0x0C, 0x03, 0x01},
+	/* OPP5 (360 Mhz) */
+	 {0x168, 0x0C, 0x03, 0x01} },
 	/* 19.2M values */
 	/* OPP1(90 Mhz) and OPP2(180 Mhz)*/
 	{{0x0E1, 0x0B, 0x06, 0x04}, {0x0E1, 0x0B, 0x06, 0x02},
@@ -490,10 +490,10 @@
 			valid_rate = clk_round_rate(p_vdd1_clk, S500M);
 			break;
 		case PRCM_VDD1_OPP4:
-			valid_rate = clk_round_rate(p_vdd1_clk, S550M);
+			valid_rate = clk_round_rate(p_vdd1_clk, S800M);
 			break;
 		case PRCM_VDD1_OPP5:
-			valid_rate = clk_round_rate(p_vdd1_clk, S600M);
+			valid_rate = clk_round_rate(p_vdd1_clk, S1005M);
 			break;
 		}
 		p_vdd1_clk->set_rate(p_vdd1_clk, valid_rate);
@@ -510,8 +510,8 @@
 	{125,  90, CO_VDD1_OPP1, PRCM_VDD1_OPP1},
 	{250, 180, CO_VDD1_OPP2, PRCM_VDD1_OPP2},
 	{500, 360, CO_VDD1_OPP3, PRCM_VDD1_OPP3},
-	{550, 396, CO_VDD1_OPP4, PRCM_VDD1_OPP4},
-	{600, 430, CO_VDD1_OPP5, PRCM_VDD1_OPP5},
+	{800, 360, CO_VDD1_OPP4, PRCM_VDD1_OPP4},
+	{1005, 360, CO_VDD1_OPP5, PRCM_VDD1_OPP5},
 };
 static struct vdd2_core_freq_d {
 	unsigned int freq;
@@ -524,7 +524,7 @@
 };
 
 static unsigned int rnd_rate_vdd1[5] = {
-	S125M, S250M, S500M, S550M, S600M
+	S125M, S250M, S500M, S800M, S1005M
 };
 static unsigned int rnd_rate_vdd2[3] = {
 	0, S83M, S166M
@@ -1541,4 +1541,52 @@
 	return -1;
 }
 
+void omap_pm_opp_get_volts(u8 vdd1_volts[]) {
+	memcpy(vdd1_volts,mpu_iva2_vdd1_volts,sizeof(mpu_iva2_vdd1_volts));
+}
+EXPORT_SYMBOL(omap_pm_opp_get_volts);
+
+void omap_pm_opp_set_volts(u8 vdd1_volts[]) {
+	memcpy(mpu_iva2_vdd1_volts,vdd1_volts,sizeof(mpu_iva2_vdd1_volts));
+	prcm_do_voltage_scaling(current_vdd1_opp, current_vdd1_opp-1);
+}
+EXPORT_SYMBOL(omap_pm_opp_set_volts);
+
+void omap_pm_opp_get_vdd2_volts(u8 *vdd2_volts[]) {
+	memcpy(vdd2_volts,core_l3_vdd2_volts,sizeof(core_l3_vdd2_volts));
+}
+EXPORT_SYMBOL(omap_pm_opp_get_vdd2_volts);
+
+void omap_pm_opp_set_vdd2_volts(u8 vdd2_volts[]) {
+	memcpy(core_l3_vdd2_volts,vdd2_volts,sizeof(core_l3_vdd2_volts));
+	prcm_do_voltage_scaling(current_vdd2_opp, current_vdd2_opp-1);
+}
+EXPORT_SYMBOL(omap_pm_opp_set_vdd2_volts);
+
+void omap_pm_opp_get_vdd2_freq(u8 *vdd2_freqs[]) {
+	int i;
+	u8 f[MAX_VDD2_OPP];
+
+	for(i=0;i < MAX_VDD2_OPP;i++)
+		f[i]=(u8 )vdd2_core_freq[i].freq;
+	memcpy(vdd2_freqs,f,sizeof(f));
+}
+EXPORT_SYMBOL(omap_pm_opp_get_vdd2_freq);
+
+unsigned int prcm_get_current_vdd1_opp_no(void) {
+	return get_opp_no(current_vdd1_opp);
+}
+EXPORT_SYMBOL(prcm_get_current_vdd1_opp_no);
+
+unsigned short get_vdd1_arm_opp_for_freq(unsigned int freq)
+{
+        int i;
+        for (i = 0; i < ARRAY_SIZE(vdd1_arm_dsp_freq); i++) {
+                if (vdd1_arm_dsp_freq[i].freq_mpu == (freq / 1000)) {
+                        return i+1;
+                }
+        }
+        return 0;
+}
+EXPORT_SYMBOL(get_vdd1_arm_opp_for_freq);
 
--- linux-2.6.24-palm/drivers/cpufreq/cpufreq_override.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/cpufreq/cpufreq_override.c	2011-05-25 22:52:57.000000000 -0400
@@ -0,0 +1,364 @@
+/*
+ *  drivers/cpufreq/cpufreq_override.c
+ *
+ *  	Marco Benton <marco@unixpsycho.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/cpu.h>
+#include <linux/sysfs.h>
+#include <linux/cpufreq.h>
+#include <linux/jiffies.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
+
+// VDD1 Vsel max
+#define VDD1_VSEL_MAX 112
+
+// VDD1 Vsel min
+#define VDD1_VSEL_MIN 25
+
+// VDD2 Vsel max
+#define VDD2_VSEL_MAX 55
+
+// VDD2 Vsel min
+#define VDD2_VSEL_MIN 25
+
+// High temp alarm and cap
+#define HIGHTEMP_SCALEBACK 55
+
+//Reset temp from alarm
+#define LOWTEMP_RESET 50
+
+// Polling frequency secs
+#define BATTERY_POLLING 1800
+#define TEMP_POLLING 2
+#define CHARGER_POLLING 3
+
+// Battery scaleback percent
+#define BATTERY_PERCENT 20
+
+// Battery scaleback speed
+#define SCALEBACK_SPEED 500000
+
+struct ovrd {
+	bool overtemp_alarm;
+	bool battery_alarm;
+	bool charging_state;
+	bool ch_override;
+	u32 prev_maxspeed;
+	u32 override_hightemp;
+	u32 override_lowtemp;
+	int battery_scaleback_percent;
+} ovrdcfg={0,0,0,0,0,HIGHTEMP_SCALEBACK,LOWTEMP_RESET,BATTERY_PERCENT};
+
+static struct ovrd *ovrd_policy=&ovrdcfg;
+
+void	omap_pm_opp_get_volts(u8 vdd1_volts[]),
+	omap_pm_opp_set_volts(u8 vdd1_volts[]),
+	omap_pm_opp_get_vdd2_volts(u8 *vdd2_volts[]),
+	omap_pm_opp_set_vdd2_volts(u8 vdd2_volts[]),
+	omap_pm_opp_get_vdd2_freq(u8 *vdd2_freqs[]),
+	vdemand_set_scaleback(bool status);
+
+int	omap34xx_get_temp(void),
+	cpufreq_set_policy(struct cpufreq_policy *policy),
+	ds2784_getpercent(int *ret_percent),
+	gadget_event_state_current(void),
+	ds2784_getcurrent(int *ret_current);
+
+unsigned short		get_vdd1_arm_opp_for_freq(unsigned int freq);
+
+static inline void	check_temp(struct work_struct *work),
+			check_battery(struct work_struct *work),
+			check_charger(struct work_struct *work);
+
+static	DEFINE_MUTEX(override_mutex);
+static	DECLARE_DELAYED_WORK(dbs_work, check_temp);
+static	DECLARE_DELAYED_WORK(dbs_work2, check_battery);
+static	DECLARE_DELAYED_WORK(dbs_work3, check_charger);
+
+#define CPUFREQ_OVERRIDE_ATTR(_name,_show,_store) \
+static struct freq_attr _attr_##_name = {\
+        .attr = {.name = __stringify(_name), .mode = 0644, }, \
+        .show = _show,\
+        .store = _store,\
+};
+
+#define CPUFREQ_OVERRIDE_ATTR2(_name,_show) \
+static struct freq_attr _attr_##_name = {\
+	.attr = {.name = __stringify(_name), .mode = 0444, }, \
+	.show = _show,\
+};
+
+static void change_freq_low(void) {
+	struct cpufreq_policy new_policy;
+
+	vdemand_set_scaleback(1);
+	cpufreq_get_policy(&new_policy,0);
+	ovrd_policy->prev_maxspeed = new_policy.max;
+	new_policy.max=SCALEBACK_SPEED;
+	cpufreq_set_policy(&new_policy);
+}
+
+static void change_freq_high(void) {
+	struct cpufreq_policy new_policy;
+
+	vdemand_set_scaleback(0);
+	cpufreq_get_policy(&new_policy,0);
+	new_policy.max=ovrd_policy->prev_maxspeed;;
+	cpufreq_set_policy(&new_policy);
+}
+
+static unsigned long int secs_to_jiffies(unsigned int secs) {
+        return secs * HZ;
+}
+
+static inline void check_charger(struct work_struct *work) {
+	int cur, current_mA;
+
+	if(ovrd_policy->overtemp_alarm || ovrd_policy->battery_alarm) goto n1;
+
+	ds2784_getcurrent(&cur);
+	current_mA=gadget_event_state_current();
+
+	if((cur>0) && (current_mA > 100 && current_mA < 500)) {
+		// Assume Touchstone
+		if(!ovrd_policy->charging_state) {
+			ovrd_policy->charging_state=1;
+			change_freq_low();
+			printk("override: TS found!\n");
+		}
+	} 
+	else {
+		if(current_mA == 1000) {
+			if(!ovrd_policy->charging_state) {
+				ovrd_policy->charging_state=1;
+				change_freq_low();
+				printk("override: 1000mA charger found!\n");
+			}
+		}
+		else {
+			if(ovrd_policy->charging_state) {
+				ovrd_policy->charging_state=0;
+				change_freq_high();
+				printk("override: charger unplugged!\n");
+			}
+		}
+	}
+n1:
+	 schedule_delayed_work(&dbs_work3,secs_to_jiffies(CHARGER_POLLING));
+}
+
+static inline void check_temp(struct work_struct *work) {
+        u32 cputemp;
+
+	if(ovrd_policy->charging_state || ovrd_policy->battery_alarm) goto out;
+
+        cputemp = omap34xx_get_temp();    // Get CPU temp
+
+	// Check values in case driver hasnt polled
+	cputemp = (cputemp < 100) ? cputemp : 0;
+
+        if(cputemp > ovrd_policy->override_hightemp) {
+                if(!ovrd_policy->overtemp_alarm) {
+                        printk("override: CPU temp warning! %dC\n",cputemp);
+                        ovrd_policy->overtemp_alarm = 1;
+			change_freq_low();
+                }
+        }
+        else {
+                if((ovrd_policy->overtemp_alarm) &&
+		  (cputemp < ovrd_policy->override_lowtemp)) {
+                        printk("override: CPU temp back under control! %dC\n",
+								cputemp);
+                        if (ovrd_policy->overtemp_alarm) {
+                        	ovrd_policy->overtemp_alarm = 0;
+				change_freq_high();
+			}
+                }
+        }
+out:
+	schedule_delayed_work(&dbs_work,secs_to_jiffies(TEMP_POLLING));
+}
+
+static inline void check_battery(struct work_struct *work) { 
+        int battery_per;
+
+        if(ovrd_policy->charging_state || ovrd_policy->overtemp_alarm)
+		goto out;
+
+        ds2784_getpercent(&battery_per);  // Get battery percent left
+
+	if(battery_per < ovrd_policy->battery_scaleback_percent) {
+		if(!ovrd_policy->battery_alarm) {
+			printk("override: battery low! < %d%%\n",battery_per);
+			ovrd_policy->battery_alarm = 1;
+			change_freq_low();
+		}
+	}
+	else {
+		if(ovrd_policy->battery_alarm) {
+			printk("override: battery OK\n");
+			ovrd_policy->battery_alarm = 0;
+			change_freq_high();
+		}
+	}
+
+out:
+	schedule_delayed_work(&dbs_work2,secs_to_jiffies(BATTERY_POLLING));
+}
+
+static ssize_t show_vdd1_vsel_max(struct cpufreq_policy *policy, char *buf) {
+	return sprintf(buf, "%hu\n",VDD1_VSEL_MAX);
+}
+
+static ssize_t show_vdd1_vsel_min(struct cpufreq_policy *policy, char *buf) {
+	return sprintf(buf, "%hu\n",VDD1_VSEL_MIN);
+}
+CPUFREQ_OVERRIDE_ATTR2(vdd1_vsel_max,show_vdd1_vsel_max);
+CPUFREQ_OVERRIDE_ATTR2(vdd1_vsel_min,show_vdd1_vsel_min);
+
+static ssize_t show_vdd2_vsel_max(struct cpufreq_policy *policy, char *buf) {
+        return sprintf(buf, "%hu\n",VDD2_VSEL_MAX);
+}
+
+static ssize_t show_vdd2_vsel_min(struct cpufreq_policy *policy, char *buf) {
+        return sprintf(buf, "%hu\n",VDD2_VSEL_MIN);
+}
+CPUFREQ_OVERRIDE_ATTR2(vdd2_vsel_min,show_vdd2_vsel_min);
+CPUFREQ_OVERRIDE_ATTR2(vdd2_vsel_max,show_vdd2_vsel_max);
+
+static ssize_t show_ch_override(struct cpufreq_policy *policy, char *buf) {
+        return sprintf(buf, "%hu\n",ovrd_policy->ch_override);
+}
+
+static ssize_t store_ch_override(struct cpufreq_policy *policy,
+					const char *buf, size_t count) {
+	u8 override=0;
+
+	if(sscanf(buf, "%hhu", &override) == 1) {
+		override=(override) ? 1 : 0;
+		if(override) {
+			ovrd_policy->charging_state=0;
+			if(!ovrd_policy->ch_override)
+				cancel_delayed_work(&dbs_work3);
+			change_freq_high();
+			printk("override: charger override enabled\n");
+		}
+		else
+			if(ovrd_policy->ch_override)
+				schedule_delayed_work(&dbs_work3,
+					secs_to_jiffies(CHARGER_POLLING));
+		ovrd_policy->ch_override=override;
+	}
+	else printk("override: invalid charger override value\n");
+
+	return count;
+}
+
+static ssize_t show_hightemp_scaleback(struct cpufreq_policy *policy,
+						char *buf) {
+        return sprintf(buf, "%u\n", ovrd_policy->override_hightemp);
+}
+
+static ssize_t store_hightemp_scaleback(struct cpufreq_policy *policy,
+					const char *buf, size_t count) {
+        int maxtemp=0;
+
+        if(sscanf(buf, "%u", &maxtemp) == 1)
+                ovrd_policy->override_hightemp=(maxtemp)
+						? maxtemp : HIGHTEMP_SCALEBACK;
+        else printk("override: invalid max temp\n");
+
+	return count;
+}
+
+static ssize_t show_battery_scaleback_per(struct cpufreq_policy *policy,
+                                                char *buf) {
+	return sprintf(buf, "%u\n", ovrd_policy->battery_scaleback_percent);
+}
+
+static ssize_t store_battery_scaleback_per(struct cpufreq_policy *policy,
+                                           const char *buf, size_t count) {
+	int bat=0;
+
+	if(sscanf(buf, "%u", &bat) == 1)
+		ovrd_policy->battery_scaleback_percent=(bat < 100)
+						? bat : BATTERY_PERCENT;
+	else printk("override: invalid battery percentage\n");
+
+	return count;
+}
+
+static ssize_t show_lowtemp_reset(struct cpufreq_policy *policy, char *buf) {
+
+        return sprintf(buf, "%u\n", ovrd_policy->override_lowtemp);
+}
+
+static ssize_t store_lowtemp_reset(struct cpufreq_policy *policy,
+						const char *buf,
+						size_t count) {
+        int lowtemp=0;
+
+        if(sscanf(buf, "%u", &lowtemp) == 1)
+                ovrd_policy->override_lowtemp=(lowtemp)
+						? lowtemp : LOWTEMP_RESET;
+        else printk("override: invalid low temp\n");
+
+	return count;
+}
+
+CPUFREQ_OVERRIDE_ATTR(battery_scaleback_percent,
+			show_battery_scaleback_per,
+			store_battery_scaleback_per);
+CPUFREQ_OVERRIDE_ATTR(cpu_hightemp_alarm,show_hightemp_scaleback,
+			store_hightemp_scaleback);
+CPUFREQ_OVERRIDE_ATTR(cpu_hightemp_reset,show_lowtemp_reset,
+			store_lowtemp_reset);
+CPUFREQ_OVERRIDE_ATTR(override_charger,show_ch_override,store_ch_override);
+
+static struct attribute *default_attrs[] = {
+        &_attr_vdd1_vsel_min.attr,
+        &_attr_vdd1_vsel_max.attr,
+	&_attr_vdd2_vsel_min.attr,
+	&_attr_vdd2_vsel_max.attr,
+        &_attr_cpu_hightemp_alarm.attr,
+        &_attr_cpu_hightemp_reset.attr,
+	&_attr_battery_scaleback_percent.attr,
+	&_attr_override_charger.attr,
+        NULL
+};
+
+static struct attribute_group override_attr_group = {
+        .attrs = default_attrs,
+        .name = "override"
+};
+
+int cpufreq_override_driver_init(void) {
+        struct cpufreq_policy *data = cpufreq_cpu_get(0);
+	schedule_delayed_work(&dbs_work,secs_to_jiffies(TEMP_POLLING));
+	schedule_delayed_work(&dbs_work2,secs_to_jiffies(BATTERY_POLLING));
+	schedule_delayed_work(&dbs_work3,secs_to_jiffies(CHARGER_POLLING));
+        return sysfs_create_group(&data->kobj,&override_attr_group);
+}
+EXPORT_SYMBOL(cpufreq_override_driver_init);
+
+void cpufreq_override_driver_exit(void) {
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+	cancel_delayed_work(&dbs_work);
+	cancel_delayed_work(&dbs_work2);
+	cancel_delayed_work(&dbs_work3);
+	sysfs_remove_group(&policy->kobj, &override_attr_group);
+	flush_scheduled_work();
+}
+EXPORT_SYMBOL(cpufreq_override_driver_exit);
+
+MODULE_AUTHOR ("marco@unixpsycho.com");
+MODULE_DESCRIPTION ("'cpufreq_override' - A driver to do cool stuff ");
+MODULE_LICENSE ("GPL");
--- linux-2.6.24-palm/drivers/cpufreq/cpufreq_vdemand.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/cpufreq/cpufreq_vdemand.c	2011-05-25 22:39:52.000000000 -0400
@@ -0,0 +1,416 @@
+/*
+ *  linux/drivers/cpufreq/cpufreq_vdemand.c
+ *
+ *  Marco Benton marco@unixpsycho.com 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/kernel_stat.h>
+#include <asm/arch/prcm.h>
+
+#define LOW 0
+#define MED 1
+#define HIGH 2
+
+// VDD1 Vsel max
+#define VDD1_VSEL_MAX 112
+
+// VDD1 Vsel min
+#define VDD1_VSEL_MIN 25
+
+// VDD2 Vsel max
+#define VDD2_VSEL_MAX 55
+
+// VDD2 Vsel min
+#define VDD2_VSEL_MIN 33
+
+// VDD defaults
+#define VDD1_VSEL { 0x3c, 0x40, 0x44 }
+#define VDD2_VSEL { 0x24, 0x28, 0x2c }
+
+// vdemand poll rate jiffies
+#define VDEMAND_POLL_RATE 30
+
+// vdemand poll rate min
+#define VDEMAND_POLL_RATE_MIN 10
+
+// vdemand poll rate max
+#define VDEMAND_POLL_RATE_MAX 1500
+
+struct vdemand_params {
+	bool cpu_is_managed;
+	unsigned int vdemand_poll_rate;
+	u8 curr_volt_idx;
+} vdemandcfg={0,VDEMAND_POLL_RATE,HIGH};
+
+static struct vdemand_params *vdemand_cfg=&vdemandcfg;
+
+void	omap_pm_opp_set_volts(u8 vdd1_volts[]),
+	omap_pm_opp_get_volts(u8 vdd1_volts[]),
+	omap_pm_opp_set_vdd2_volts(u8 vdd2_volts[]),
+	omap_pm_opp_get_vdd2_volts(u8 *vdd2_volts[]),
+	prcm_set_constraint(u8 vdd1_min,u8 vdd1_max);
+
+int	prcm_get_current_vdd1_opp_no(void),
+	set_voltage_level(u8 vdd, u8 vsel),
+	cpufreq_set_policy(struct cpufreq_policy *policy);
+
+unsigned short	get_vdd1_arm_opp_for_freq(unsigned int freq);
+
+static unsigned int	last_load=0,
+			prev_cpu_freq=0;
+
+static cputime64_t	cur_cpu_time=0,
+			prev_cpu_time=0,
+			prev_cpu_idle=0,
+			volt_stats[3]={ 0,0,0 };
+
+static u8	v_volt[3] =		VDD1_VSEL,
+		v_volt_vdd2[3] =	VDD2_VSEL,
+		vdd1_vsel_def[3] =	VDD1_VSEL,
+		vdd2_vsel_def[3] =	VDD2_VSEL;
+
+static unsigned short	opp=0;
+
+bool		scaleback;
+
+static inline void	check_load(struct work_struct *work);
+
+static	DEFINE_MUTEX(vdemand_mutex);
+static	DECLARE_DELAYED_WORK(dbs_work, check_load);
+
+#define CPUFREQ_OVERRIDE_ATTR(_name,_show,_store) \
+static struct freq_attr _attr_##_name = {\
+	.attr = {.name = __stringify(_name), .mode = 0644, }, \
+	.show = _show,\
+	.store = _store,\
+};
+
+#define CPUFREQ_OVERRIDE_ATTR2(_name,_show) \
+static struct freq_attr _attr_##_name = {\
+        .attr = {.name = __stringify(_name), .mode = 0444, }, \
+        .show = _show,\
+};
+
+static ssize_t show_vdemand_vsel_vdd1_def(struct cpufreq_policy *policy,
+							char *buf) {
+        return sprintf(buf, "%hu %hu %hu\n", vdd1_vsel_def[2],vdd1_vsel_def[1],
+						vdd1_vsel_def[0]);
+}
+
+static ssize_t show_vdemand_vsel_vdd2_def(struct cpufreq_policy *policy,
+							char *buf) {
+        return sprintf(buf, "%hu %hu %hu\n", vdd2_vsel_def[2],vdd2_vsel_def[1],
+						vdd2_vsel_def[0]);
+}
+CPUFREQ_OVERRIDE_ATTR2(vdemand_vsel_vdd1_default,show_vdemand_vsel_vdd1_def);
+CPUFREQ_OVERRIDE_ATTR2(vdemand_vsel_vdd2_default,show_vdemand_vsel_vdd2_def);
+
+static ssize_t show_vdemand_vsel(struct cpufreq_policy *policy, char *buf) {
+	return sprintf(buf, "%hu %hu %hu\n", v_volt[2],v_volt[1],v_volt[0]);
+}
+
+static ssize_t store_vdemand_vsel(struct cpufreq_policy *policy,
+						const char *buf,
+                                                size_t count) {
+        u8 volt[3], i;
+
+        mutex_lock(&vdemand_mutex);
+
+        if(sscanf(buf, "%hhu %hhu %hhu", &volt[2],&volt[1],&volt[0])) {
+                for(i=0;i < 3;i++) {
+                        if((volt[i] < VDD1_VSEL_MIN) ||
+				(volt[i] > VDD1_VSEL_MAX)) {
+                                printk("vdemand: invalid vsel! \
+					Resetting to default!\n");
+				volt[i]=vdd1_vsel_def[i];
+                                break;
+                        }
+                }
+                if(i == 3) memcpy(v_volt,volt,sizeof(volt));
+        }
+        else printk("vdemand: missing vsel values\n");
+
+        mutex_unlock(&vdemand_mutex);
+        return count;
+}
+
+static ssize_t show_vdemand_stats(struct cpufreq_policy *policy, char *buf) {
+	return sprintf(buf, "%hu %llu\n%hu %llu\n%hu %llu\n", v_volt[2],
+			volt_stats[2],v_volt[1],volt_stats[1],v_volt[0],
+			volt_stats[0]);
+}
+CPUFREQ_OVERRIDE_ATTR2(vdemand_stats,show_vdemand_stats);
+
+static ssize_t show_vdemand_poll(struct cpufreq_policy *policy, char *buf) {
+        return sprintf(buf, "%hu\n",
+			jiffies_to_msecs(vdemand_cfg->vdemand_poll_rate));
+}
+
+static ssize_t store_vdemand_poll(struct cpufreq_policy *policy,
+						const char *buf,
+						size_t count) {
+        unsigned int i;
+
+        if(sscanf(buf, "%u", &i)) {
+		i=msecs_to_jiffies(i);
+                if((i < VDEMAND_POLL_RATE_MIN) || (i > VDEMAND_POLL_RATE_MAX))
+                        printk("vdemand: invalid \n");
+                else {
+                        vdemand_cfg->vdemand_poll_rate=i;
+                }
+        }
+        else printk("vdemand: missing value\n");
+
+        return count;
+}
+
+CPUFREQ_OVERRIDE_ATTR(vdemand_vsel_vdd1,show_vdemand_vsel,store_vdemand_vsel);
+CPUFREQ_OVERRIDE_ATTR(vdemand_poll_rate,show_vdemand_poll,store_vdemand_poll);
+
+static ssize_t show_vdemand_vsel_vdd2(struct cpufreq_policy *policy,
+								char *buf) {
+        return sprintf(buf, "%hu %hu %hu\n", v_volt_vdd2[2],v_volt_vdd2[1],
+							v_volt_vdd2[0]);
+}
+
+static ssize_t show_vdemand_poll_rate_min(struct cpufreq_policy *policy, char *buf) {
+        return sprintf(buf, "%u\n",VDEMAND_POLL_RATE_MIN);
+}
+
+static ssize_t show_vdemand_poll_rate_max(struct cpufreq_policy *policy, char *buf) {
+        return sprintf(buf, "%u\n", VDEMAND_POLL_RATE_MAX);
+}
+CPUFREQ_OVERRIDE_ATTR2(vdemand_poll_rate_min,show_vdemand_poll_rate_min);
+CPUFREQ_OVERRIDE_ATTR2(vdemand_poll_rate_max,show_vdemand_poll_rate_max);
+
+static ssize_t store_vdemand_vsel_vdd2(struct cpufreq_policy *policy,
+						const char *buf,
+                                                size_t count) {
+        u8 volt[3], i;
+
+        mutex_lock(&vdemand_mutex);
+
+        if(sscanf(buf, "%hhu %hhu %hhu", &volt[2],&volt[1],&volt[0])) {
+                for(i=0;i < 3;i++) {
+                        if((volt[i] < VDD2_VSEL_MIN) ||
+                                (volt[i] > VDD2_VSEL_MAX)) {
+                                printk("vdemand: invalid vsel! \
+					Resetting to default!\n");
+				volt[i]=vdd2_vsel_def[i];
+                                break;
+                        }
+                }
+                if(i == 3) memcpy(v_volt_vdd2,volt,sizeof(volt));
+        }
+        else printk("vdemand: missing vsel values\n");
+
+        mutex_unlock(&vdemand_mutex);
+        return count;
+}
+
+CPUFREQ_OVERRIDE_ATTR(vdemand_vsel_vdd2,show_vdemand_vsel_vdd2,
+						store_vdemand_vsel_vdd2);
+
+static struct attribute *default_attrs[] = {
+        &_attr_vdemand_vsel_vdd1.attr,
+        &_attr_vdemand_vsel_vdd2.attr,
+	&_attr_vdemand_stats.attr,
+        &_attr_vdemand_poll_rate.attr,
+        &_attr_vdemand_vsel_vdd1_default.attr,
+        &_attr_vdemand_vsel_vdd2_default.attr,
+	&_attr_vdemand_poll_rate_min.attr,
+	&_attr_vdemand_poll_rate_max.attr,
+        NULL
+};
+
+static struct attribute_group vdemand_attr_group = {
+        .attrs = default_attrs,
+        .name = "vdemand"
+};
+
+static inline cputime64_t get_cpu_idle_time(unsigned int cpu) {
+        cputime64_t idle_time;
+        cputime64_t cur_jiffies;
+        cputime64_t busy_time;
+
+        cur_jiffies = jiffies64_to_cputime64(get_jiffies_64());
+        busy_time = cputime64_add(kstat_cpu(cpu).cpustat.user,
+                        kstat_cpu(cpu).cpustat.system);
+
+        busy_time = cputime64_add(busy_time,kstat_cpu(cpu).cpustat.irq);
+        busy_time = cputime64_add(busy_time,kstat_cpu(cpu).cpustat.softirq);
+        busy_time = cputime64_add(busy_time,kstat_cpu(cpu).cpustat.steal);
+
+        idle_time = cputime64_sub(cur_jiffies, busy_time);
+        return idle_time;
+}
+
+static inline void check_load(struct work_struct *work) {
+	unsigned int tmp_idle_ticks,idle_ticks,total_ticks,load=0;
+	cputime64_t total_idle_ticks,cur_jiffies;
+
+	mutex_lock(&vdemand_mutex);
+
+	if(!opp) goto out;
+
+	idle_ticks = UINT_MAX;
+        cur_jiffies = jiffies64_to_cputime64(get_jiffies_64());
+        total_ticks = (unsigned int) cputime64_sub(cur_jiffies,cur_cpu_time);
+	cur_cpu_time = get_jiffies_64();
+
+        if (!total_ticks) goto out;
+
+	total_idle_ticks = get_cpu_idle_time(0);
+	tmp_idle_ticks = (unsigned int )cputime64_sub(total_idle_ticks,
+								prev_cpu_idle);
+	prev_cpu_idle = total_idle_ticks;
+
+	if(tmp_idle_ticks < idle_ticks) idle_ticks = tmp_idle_ticks;
+	if(likely(total_ticks > idle_ticks))
+		load = (100 * (total_ticks - idle_ticks)) / total_ticks;
+
+	if(!last_load) goto out;
+
+	volt_stats[vdemand_cfg->curr_volt_idx] =
+			cputime64_add(volt_stats[vdemand_cfg->curr_volt_idx],
+			cputime_sub(cur_cpu_time,prev_cpu_time));
+	prev_cpu_time = cur_cpu_time;
+
+	if((load < 30) && (last_load > 29)) {
+		set_voltage_level(1,v_volt[0]);
+		set_voltage_level(2,v_volt_vdd2[0]);
+		vdemand_cfg->curr_volt_idx=LOW;
+		goto out;
+	}
+        if(((load > 29) && (load < 70)) &&
+	    ((last_load < 30) || (last_load > 69))) {
+		set_voltage_level(1,v_volt[1]);
+		set_voltage_level(2,v_volt_vdd2[1]);
+		vdemand_cfg->curr_volt_idx=MED;
+		goto out;
+        }
+	if((load > 69) && (last_load < 70)) {
+		set_voltage_level(1,v_volt[2]);
+		set_voltage_level(2,v_volt_vdd2[2]);
+		vdemand_cfg->curr_volt_idx=HIGH;
+        }
+
+out:
+	last_load=load;
+	mutex_unlock(&vdemand_mutex);
+	schedule_delayed_work(&dbs_work,
+			msecs_to_jiffies(vdemand_cfg->vdemand_poll_rate));
+
+	return;
+}
+
+static void set_new_voltage(void) {
+	u8 tvolt[PRCM_NO_VDD1_OPPS];
+
+	omap_pm_opp_get_volts(tvolt);
+	v_volt[0]=tvolt[opp-1] - 8;
+	v_volt[1]=tvolt[opp-1] - 4;
+	v_volt[2]=tvolt[opp-1];
+	printk("vdemand: reset voltage\n");
+}
+
+void vdemand_set_scaleback(bool status) {
+	if(status) {
+		cancel_delayed_work(&dbs_work);
+		scaleback = 1;
+	} else {
+		schedule_delayed_work(&dbs_work,
+			msecs_to_jiffies(vdemand_cfg->vdemand_poll_rate));
+		scaleback = 0;
+	}
+}
+EXPORT_SYMBOL(vdemand_set_scaleback);
+
+static int cpufreq_governor_vdemand(struct cpufreq_policy *policy,
+				   unsigned int event) {
+	int rc;
+
+	switch (event) {
+		case CPUFREQ_GOV_START:
+			mutex_lock(&vdemand_mutex);
+			if(vdemand_cfg->cpu_is_managed) break;
+			vdemand_cfg->cpu_is_managed = 1;
+			last_load = 0;
+			scaleback = 0;
+			prev_cpu_idle = get_cpu_idle_time(0);
+			cur_cpu_time = get_jiffies_64();
+			vdemand_cfg->curr_volt_idx=HIGH;
+			prev_cpu_time = cur_cpu_time;
+			rc = sysfs_create_group(&policy->kobj,
+						&vdemand_attr_group);
+			__cpufreq_driver_target(policy,
+						policy->max,CPUFREQ_RELATION_H);
+			opp=get_vdd1_arm_opp_for_freq(policy->max);
+			set_new_voltage();
+			memcpy(vdd1_vsel_def,v_volt,sizeof(v_volt));
+			schedule_delayed_work(&dbs_work,
+			     msecs_to_jiffies(vdemand_cfg->vdemand_poll_rate));
+			prev_cpu_freq = policy->max;
+			mutex_unlock(&vdemand_mutex);
+			break;
+		case CPUFREQ_GOV_STOP:
+			mutex_lock(&vdemand_mutex);
+			vdemand_cfg->cpu_is_managed = 0;
+			cancel_delayed_work(&dbs_work);
+			sysfs_remove_group(&policy->kobj, &vdemand_attr_group);
+			mutex_unlock(&vdemand_mutex);
+			break;
+		case CPUFREQ_GOV_LIMITS:
+			mutex_lock(&vdemand_mutex);
+			__cpufreq_driver_target(policy,
+					policy->max, CPUFREQ_RELATION_H);
+			opp=get_vdd1_arm_opp_for_freq(policy->max);
+			if((!scaleback) && (prev_cpu_freq != policy->max)) {
+				set_new_voltage();
+				prev_cpu_freq = policy->max;
+			}
+			printk("vdemand: policy change: opp=%hu\n",opp);
+			mutex_unlock(&vdemand_mutex);
+			break;
+		}
+		return 0;
+}
+
+struct cpufreq_governor cpufreq_gov_vdemand = {
+	.name		= "vdemand",
+	.governor	= cpufreq_governor_vdemand,
+	.owner		= THIS_MODULE,
+};
+EXPORT_SYMBOL(cpufreq_gov_vdemand);
+
+static int __init cpufreq_gov_vdemand_init(void) {
+	return cpufreq_register_governor(&cpufreq_gov_vdemand);
+}
+
+static void __exit cpufreq_gov_vdemand_exit(void) {
+	flush_scheduled_work();
+	cpufreq_unregister_governor(&cpufreq_gov_vdemand);
+}
+
+MODULE_AUTHOR ("marco@unixpsycho.com");
+MODULE_DESCRIPTION ("CPUfreq policy governor 'vdemand'");
+MODULE_LICENSE ("GPL");
+
+fs_initcall(cpufreq_gov_vdemand_init);
+module_exit(cpufreq_gov_vdemand_exit);
--- linux-2.6.24-palm/arch/arm/mach-omap3pe/clock.c	2011-02-28 17:03:31.000000000 -0500
+++ linux-2.6.24-AV8B/arch/arm/mach-omap3pe/clock.c	2011-03-03 16:09:44.000000000 -0500
@@ -709,6 +709,9 @@
 
 	prcm = vdd1_rate_table + ARRAY_SIZE(vdd1_rate_table) -1;
 	for (; prcm->speed; prcm--) {
+#ifdef CONFIG_CPU_FREQ_OVERRIDE_STRIPOPP
+		if((prcm->speed / 1000) < 500000) continue;
+#endif
 		freq_table[i].index = i;
 		freq_table[i].frequency = prcm->speed / 1000;
 		i++;
--- linux-2.6.24-palm/drivers/usb/gadget/gadget_event.c	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/usb/gadget/gadget_event.c	2011-03-03 16:09:44.000000000 -0500
@@ -362,6 +362,12 @@
 }
 EXPORT_SYMBOL(gadget_event_power_state_changed);
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+int gadget_event_state_current(void) {
+	return the_state.current_mA;
+}
+#endif
+
 static int __init init(void)
 {
 	int ret = 0;
--- linux-2.6.24-palm/drivers/w1/slaves/w1_ds2784.c	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/w1/slaves/w1_ds2784.c	2011-03-03 16:09:44.000000000 -0500
@@ -1133,11 +1133,20 @@
 */
 static struct device *battery_device = NULL;
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+int ds2784_getpercent(int *ret_percent)
+{
+        if (!battery_device) return -1;
+        return ds2784_getpercent_dev(battery_device, ret_percent);
+}
+EXPORT_SYMBOL(ds2784_getpercent);
+#else
 static int ds2784_getpercent(int *ret_percent)
 {
 	if (!battery_device) return -1;
 	return ds2784_getpercent_dev(battery_device, ret_percent);
 }
+#endif
 
 static int ds2784_getvoltage(int *ret_voltage)
 {
@@ -1151,11 +1160,20 @@
 	return ds2784_gettemperature_dev(battery_device, ret_temperature);
 }
 
+#ifdef CONFIG_CPU_FREQ_OVERRIDE
+int ds2784_getcurrent(int *ret_current)
+{
+        if (!battery_device) return -1;
+        return ds2784_getcurrent_dev(battery_device, ret_current);
+}
+EXPORT_SYMBOL(ds2784_getcurrent);
+#else
 static int ds2784_getcurrent(int *ret_current)
 {
 	if (!battery_device) return -1;
 	return ds2784_getcurrent_dev(battery_device, ret_current);
 }
+#endif
 
 static struct battery_ops ds2784_battery_ops = {
 	.get_percent       = ds2784_getpercent,
--- linux-2.6.24-palm/arch/arm/mach-omap3pe/clock.h	2011-02-28 17:03:31.000000000 -0500
+++ linux-2.6.24-AV8B/arch/arm/mach-omap3pe/clock.h	2011-05-25 20:58:45.000000000 -0400
@@ -47,9 +47,8 @@
 #define S125M	125000000
 #define S250M	250000000
 #define S500M	500000000
-#define S550M	550000000
-#define S625M	625000000
-#define S600M	600000000
+#define S800M	800000000
+#define S1005M	1005000000
 
 /* Macro to enable clock control via clock framework */
 #define ENABLE_CLOCKCONTROL 1
--- linux-2.6.24-palm/arch/arm/mach-omap3pe/clock_tree.h	2011-02-28 17:03:31.000000000 -0500
+++ linux-2.6.24-AV8B/arch/arm/mach-omap3pe/clock_tree.h	2011-05-25 20:58:17.000000000 -0400
@@ -90,9 +90,9 @@
 	/*OPP3*/
 	{S500M, PRCM_VDD1_OPP3, RATE_IN_343X},
 	/*OPP4*/
-	{S550M, PRCM_VDD1_OPP4, RATE_IN_343X},
+	{S800M, PRCM_VDD1_OPP4, RATE_IN_343X},
 	/*OPP5*/
-	{S600M, PRCM_VDD1_OPP5, RATE_IN_343X},
+	{S1005M, PRCM_VDD1_OPP5, RATE_IN_343X},
 };
 
 static struct vdd_prcm_config vdd2_rate_table[MAX_VDD2_OPP +1] = {
--- linux-2.6.24-palm/arch/arm/mach-omap3pe/constraint.c	2011-02-28 17:03:31.000000000 -0500
+++ linux-2.6.24-AV8B/arch/arm/mach-omap3pe/constraint.c	2011-05-25 20:59:56.000000000 -0400
@@ -32,7 +32,6 @@
 #include <asm/arch/prcm.h>
 #include "prcm_opp.h"
 
-
 /******************************************************************************
  *
  * DEBUG
@@ -66,9 +65,9 @@
 static struct atomic_notifier_head freq_dsp_pre_notifier_list;
 static struct atomic_notifier_head freq_dsp_post_notifier_list;
 
-#define min_vdd1_opp    CO_VDD1_OPP1
+#define min_vdd1_opp    CO_VDD1_OPP3
 #define max_vdd1_opp    CO_VDD1_OPP5
-#define min_vdd2_opp    CO_VDD2_OPP2
+#define min_vdd2_opp    CO_VDD2_OPP3
 #define max_vdd2_opp    CO_VDD2_OPP3
 
 /******************************************************************************
--- linux-2.6.24-palm/arch/arm/mach-omap3pe/Kconfig	2011-02-28 17:03:31.000000000 -0500
+++ linux-2.6.24-AV8B/arch/arm/mach-omap3pe/Kconfig	2011-03-03 16:09:44.000000000 -0500
@@ -138,7 +138,7 @@
 	  Select this option if you want to boot at OPP4.
 
 config OMAP3ES2_VDD1_OPP5
-	bool "MPU-625Mhz/DSP-430Mhz(OPP5)"
+	bool "MPU-1005Mhz/DSP-430Mhz(OPP5)"
 	depends on OMAP3_PM
 	help
 	  Select this option if you want to boot at OPP5.
--- linux-2.6.24-palm/include/asm-arm/arch-omap/resource.h	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/include/asm-arm/arch-omap/resource.h	2011-05-25 21:00:33.000000000 -0400
@@ -29,14 +29,14 @@
 #include <linux/notifier.h>
 
 
-#define curr_vdd1_opp   3
+#define curr_vdd1_opp   5
 #define curr_vdd2_opp   3
-#define min_vdd1_opp    CO_VDD1_OPP1
+#define min_vdd1_opp    CO_VDD1_OPP3
 #define max_vdd1_opp    CO_VDD1_OPP5
-#define min_vdd2_opp    CO_VDD2_OPP2
+#define min_vdd2_opp    CO_VDD2_OPP3
 #define max_vdd2_opp    CO_VDD2_OPP3
 
-#define CURR_VDD1_OPP	3
+#define CURR_VDD1_OPP	5
 #define CURR_VDD2_OPP	3
 /* Flags to denote Pool usage */
 #define RES_UNUSED		0x0
@@ -269,17 +269,17 @@
 #define T2_VUSB3V1_MAX  0x2
 
 /* Frequencies and Voltages for OPPs */
-#define CURR_ARM_FREQ 	500
+#define CURR_ARM_FREQ 	1005
 #define CURR_DSP_FREQ 	360
-#define curr_arm_freq 	500
+#define curr_arm_freq 	1005
 #define curr_dsp_freq 	360
-#define min_arm_freq 	125
-#define max_arm_freq 	600
+#define min_arm_freq 	500
+#define max_arm_freq 	1005
 #define min_dsp_freq 	90
-#define max_dsp_freq 	430
-#define MIN_VDD1_OPP 	CO_VDD1_OPP1
+#define max_dsp_freq 	360
+#define MIN_VDD1_OPP 	CO_VDD1_OPP3
 #define MAX_VDD1_OPP 	CO_VDD1_OPP5
-#define MIN_VDD2_OPP 	CO_VDD2_OPP2
+#define MIN_VDD2_OPP 	CO_VDD2_OPP3
 #define MAX_VDD2_OPP 	CO_VDD2_OPP3
 
 /* Structure returned to the framework user as handle */
--- linux-2.6.24-palm/drivers/media/video/omappe/omap34xx-isp.c	2011-02-28 17:03:32.000000000 -0500
+++ linux-2.6.24-AV8B/drivers/media/video/omappe/omap34xx-isp.c	2011-03-06 11:58:52.000000000 -0500
@@ -414,8 +414,8 @@
 	SPEW(1, "+++ %s\n", __func__);
 
 	/* constraint values are from ti reference code */
-	if ((rc = constraint_set(data->vdd1_co, CO_VDD1_OPP3)))
-		goto exit;
+//	if ((rc = constraint_set(data->vdd1_co, CO_VDD1_OPP3)))
+//		goto exit;
 
 	if ((rc = constraint_set(data->vdd2_co, CO_VDD2_OPP3)))
 		goto constraint_set_vdd2_failed;
@@ -484,7 +484,7 @@
 	clk_disable(data->iclk);
 	constraint_remove(data->lat_co);
 	constraint_remove(data->vdd2_co);
-	constraint_remove(data->vdd1_co);
+//	constraint_remove(data->vdd1_co);
 
 	SPEW(1, "--- %s\n", __func__);
 }
@@ -625,10 +625,10 @@
 	data->ccdc_cfg_bswd = pdata->ccdc_cfg_bswd;
 	data->ccdc_fmtcfg_vpin = pdata->ccdc_fmtcfg_vpin;
 
-	if (IS_ERR(data->vdd1_co = constraint_get("cam_vdd1", &vdd1_co_id))) {
-		rc = PTR_ERR(data->vdd1_co);
-		goto constraint_get_vdd1_failed;
-	}
+//	if (IS_ERR(data->vdd1_co = constraint_get("cam_vdd1", &vdd1_co_id))) {
+//		rc = PTR_ERR(data->vdd1_co);
+//		goto constraint_get_vdd1_failed;
+//	}
 
 	if (IS_ERR(data->vdd2_co = constraint_get("cam_vdd2", &vdd2_co_id))) {
 		rc = PTR_ERR(data->vdd2_co);
@@ -742,7 +742,7 @@
 	clk_put(data->iclk);
 	constraint_put(data->lat_co);
 	constraint_put(data->vdd2_co);
-	constraint_put(data->vdd1_co);
+//	constraint_put(data->vdd1_co);
 	kfree(data);
 
 	SPEW(1, "--- %s\n", __func__);
